// <auto-generated>
/*
 * Admin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using SharedModule.HttpApi.Helpers;
using Microsoft.AspNetCore.Http;
using EleonsoftProxy.Client;
using EleonsoftProxy.Model;
using System.Diagnostics.CodeAnalysis;

namespace EleonsoftProxy.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IBackgroundJobApi : IApi
    {
        void UseOAuthAuth();
        void UseApiAuth();
		void UseDefaultAuth();


        /// <summary>
        /// The class containing the events
        /// </summary>
        BackgroundJobApiEvents Events { get; }

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse> BackgroundJobsBackgroundJobCancelBackgroundJobAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse> BackgroundJobsBackgroundJobCancelBackgroundJobOrDefaultAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="backgroundJobsBackgroundJobExecutionCompleteDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCompleteApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobCompleteApiResponse> BackgroundJobsBackgroundJobCompleteAsync(Option<BackgroundJobsBackgroundJobExecutionCompleteDto> backgroundJobsBackgroundJobExecutionCompleteDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="backgroundJobsBackgroundJobExecutionCompleteDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCompleteApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobCompleteApiResponse> BackgroundJobsBackgroundJobCompleteOrDefaultAsync(Option<BackgroundJobsBackgroundJobExecutionCompleteDto> backgroundJobsBackgroundJobExecutionCompleteDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="backgroundJobsCreateBackgroundJobDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCreateApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobCreateApiResponse> BackgroundJobsBackgroundJobCreateAsync(Option<BackgroundJobsCreateBackgroundJobDto> backgroundJobsCreateBackgroundJobDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="backgroundJobsCreateBackgroundJobDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCreateApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobCreateApiResponse> BackgroundJobsBackgroundJobCreateOrDefaultAsync(Option<BackgroundJobsCreateBackgroundJobDto> backgroundJobsCreateBackgroundJobDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse> BackgroundJobsBackgroundJobGetBackgroundJobByIdAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse> BackgroundJobsBackgroundJobGetBackgroundJobByIdOrDefaultAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchQuery"> (optional)</param>
        /// <param name="statusFilter"> (optional)</param>
        /// <param name="objectTypeFilter"> (optional)</param>
        /// <param name="typeFilter"> (optional)</param>
        /// <param name="creationDateFilterStart"> (optional)</param>
        /// <param name="creationDateFilterEnd"> (optional)</param>
        /// <param name="lastExecutionDateFilterStart"> (optional)</param>
        /// <param name="lastExecutionDateFilterEnd"> (optional)</param>
        /// <param name="sorting"> (optional)</param>
        /// <param name="skipCount"> (optional)</param>
        /// <param name="maxResultCount"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse> BackgroundJobsBackgroundJobGetBackgroundJobListAsync(Option<string> searchQuery = default, Option<List<EleoncoreBackgroundJobStatus>> statusFilter = default, Option<List<string>> objectTypeFilter = default, Option<List<string>> typeFilter = default, Option<DateTime> creationDateFilterStart = default, Option<DateTime> creationDateFilterEnd = default, Option<DateTime> lastExecutionDateFilterStart = default, Option<DateTime> lastExecutionDateFilterEnd = default, Option<string> sorting = default, Option<int> skipCount = default, Option<int> maxResultCount = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="searchQuery"> (optional)</param>
        /// <param name="statusFilter"> (optional)</param>
        /// <param name="objectTypeFilter"> (optional)</param>
        /// <param name="typeFilter"> (optional)</param>
        /// <param name="creationDateFilterStart"> (optional)</param>
        /// <param name="creationDateFilterEnd"> (optional)</param>
        /// <param name="lastExecutionDateFilterStart"> (optional)</param>
        /// <param name="lastExecutionDateFilterEnd"> (optional)</param>
        /// <param name="sorting"> (optional)</param>
        /// <param name="skipCount"> (optional)</param>
        /// <param name="maxResultCount"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse> BackgroundJobsBackgroundJobGetBackgroundJobListOrDefaultAsync(Option<string> searchQuery = default, Option<List<EleoncoreBackgroundJobStatus>> statusFilter = default, Option<List<string>> objectTypeFilter = default, Option<List<string>> typeFilter = default, Option<DateTime> creationDateFilterStart = default, Option<DateTime> creationDateFilterEnd = default, Option<DateTime> lastExecutionDateFilterStart = default, Option<DateTime> lastExecutionDateFilterEnd = default, Option<string> sorting = default, Option<int> skipCount = default, Option<int> maxResultCount = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"> (optional)</param>
        /// <param name="executionId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse> BackgroundJobsBackgroundJobMarkExecutionStartedAsync(Option<Guid> jobId = default, Option<Guid> executionId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="jobId"> (optional)</param>
        /// <param name="executionId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse> BackgroundJobsBackgroundJobMarkExecutionStartedOrDefaultAsync(Option<Guid> jobId = default, Option<Guid> executionId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse> BackgroundJobsBackgroundJobRetryBackgroundJobAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse"/>&gt;</returns>
        Task<IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse> BackgroundJobsBackgroundJobRetryBackgroundJobOrDefaultAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse"/>
    /// </summary>
    public interface IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IBackgroundJobsBackgroundJobCompleteApiResponse"/>
    /// </summary>
    public interface IBackgroundJobsBackgroundJobCompleteApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<EleonsoftProxy.Model.BackgroundJobsBackgroundJobDto>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IBackgroundJobsBackgroundJobCreateApiResponse"/>
    /// </summary>
    public interface IBackgroundJobsBackgroundJobCreateApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<EleonsoftProxy.Model.BackgroundJobsBackgroundJobDto>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse"/>
    /// </summary>
    public interface IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<EleonsoftProxy.Model.BackgroundJobsFullBackgroundJobDto>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse"/>
    /// </summary>
    public interface IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<EleonsoftProxy.Model.EleoncorePagedResultDtoOfBackgroundJobsBackgroundJobHeaderDto>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse"/>
    /// </summary>
    public interface IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse"/>
    /// </summary>
    public interface IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class BackgroundJobApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnBackgroundJobsBackgroundJobCancelBackgroundJob;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorBackgroundJobsBackgroundJobCancelBackgroundJob;

        internal void ExecuteOnBackgroundJobsBackgroundJobCancelBackgroundJob(BackgroundJobApi.BackgroundJobsBackgroundJobCancelBackgroundJobApiResponse apiResponse)
        {
            OnBackgroundJobsBackgroundJobCancelBackgroundJob?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBackgroundJobsBackgroundJobCancelBackgroundJob(Exception exception)
        {
            OnErrorBackgroundJobsBackgroundJobCancelBackgroundJob?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnBackgroundJobsBackgroundJobComplete;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorBackgroundJobsBackgroundJobComplete;

        internal void ExecuteOnBackgroundJobsBackgroundJobComplete(BackgroundJobApi.BackgroundJobsBackgroundJobCompleteApiResponse apiResponse)
        {
            OnBackgroundJobsBackgroundJobComplete?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBackgroundJobsBackgroundJobComplete(Exception exception)
        {
            OnErrorBackgroundJobsBackgroundJobComplete?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnBackgroundJobsBackgroundJobCreate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorBackgroundJobsBackgroundJobCreate;

        internal void ExecuteOnBackgroundJobsBackgroundJobCreate(BackgroundJobApi.BackgroundJobsBackgroundJobCreateApiResponse apiResponse)
        {
            OnBackgroundJobsBackgroundJobCreate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBackgroundJobsBackgroundJobCreate(Exception exception)
        {
            OnErrorBackgroundJobsBackgroundJobCreate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnBackgroundJobsBackgroundJobGetBackgroundJobById;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorBackgroundJobsBackgroundJobGetBackgroundJobById;

        internal void ExecuteOnBackgroundJobsBackgroundJobGetBackgroundJobById(BackgroundJobApi.BackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse apiResponse)
        {
            OnBackgroundJobsBackgroundJobGetBackgroundJobById?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBackgroundJobsBackgroundJobGetBackgroundJobById(Exception exception)
        {
            OnErrorBackgroundJobsBackgroundJobGetBackgroundJobById?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnBackgroundJobsBackgroundJobGetBackgroundJobList;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorBackgroundJobsBackgroundJobGetBackgroundJobList;

        internal void ExecuteOnBackgroundJobsBackgroundJobGetBackgroundJobList(BackgroundJobApi.BackgroundJobsBackgroundJobGetBackgroundJobListApiResponse apiResponse)
        {
            OnBackgroundJobsBackgroundJobGetBackgroundJobList?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBackgroundJobsBackgroundJobGetBackgroundJobList(Exception exception)
        {
            OnErrorBackgroundJobsBackgroundJobGetBackgroundJobList?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnBackgroundJobsBackgroundJobMarkExecutionStarted;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorBackgroundJobsBackgroundJobMarkExecutionStarted;

        internal void ExecuteOnBackgroundJobsBackgroundJobMarkExecutionStarted(BackgroundJobApi.BackgroundJobsBackgroundJobMarkExecutionStartedApiResponse apiResponse)
        {
            OnBackgroundJobsBackgroundJobMarkExecutionStarted?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBackgroundJobsBackgroundJobMarkExecutionStarted(Exception exception)
        {
            OnErrorBackgroundJobsBackgroundJobMarkExecutionStarted?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnBackgroundJobsBackgroundJobRetryBackgroundJob;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorBackgroundJobsBackgroundJobRetryBackgroundJob;

        internal void ExecuteOnBackgroundJobsBackgroundJobRetryBackgroundJob(BackgroundJobApi.BackgroundJobsBackgroundJobRetryBackgroundJobApiResponse apiResponse)
        {
            OnBackgroundJobsBackgroundJobRetryBackgroundJob?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBackgroundJobsBackgroundJobRetryBackgroundJob(Exception exception)
        {
            OnErrorBackgroundJobsBackgroundJobRetryBackgroundJob?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class BackgroundJobApi : IBackgroundJobApi
    {
		public HttpClient HttpClient => SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, GetType().Name);
	
		private readonly EleoncoreSdkConfig _sdkConfig;
        private readonly JsonSerializerOptions _jsonSerializerOptions;
		private readonly ApiConfigurator _apiConfigurator;
		
		private string _accessTokenType;

        private readonly ILoggerFactory LoggerFactory;
        private readonly ILogger<BackgroundJobApi> Logger;

        /// <summary>
        /// The class containing the events
        /// </summary>
        public BackgroundJobApiEvents Events { get; }
		
		/// <summary>
        /// Initializes a new instance of the <see cref="BackgroundJobApi"/> class.
        /// </summary>
        /// <returns></returns>
        public BackgroundJobApi() : this(ApiConfigurator.GetConfigurator("EleonsoftProxy"))
        {
        }
		
		
        /// <summary>
        /// Initializes a new instance of the <see cref="BackgroundJobApi"/> class.
        /// </summary>
        /// <returns></returns>
        public BackgroundJobApi(ApiConfigurator apiConfigurator)
        {
			apiConfigurator.Validate();
		
			_apiConfigurator = apiConfigurator;
            _sdkConfig = apiConfigurator.SdkConfig;
            _jsonSerializerOptions = apiConfigurator.JsonSerializerOptions;
            LoggerFactory = apiConfigurator.LoggerFactory;
            Logger = LoggerFactory.CreateLogger<BackgroundJobApi>();
            Events = new BackgroundJobApiEvents();
			
        }
        


        /// <summary>
        /// Switch to use API Authorization dynamically.
        /// </summary>
        public void UseApiAuth()
		{
			if (!_sdkConfig.UseApiAuthorization)
			{
				throw new Exception("API Authorization is not configured in the SDK.");
			}

			_accessTokenType = "api";
		}

        /// <summary>
        /// Switch to use OAuth Authorization dynamically.
        /// </summary>
        public void UseOAuthAuth()
        {
            if (!_sdkConfig.UseOAuthAuthorization)
            {
                throw new Exception("OAuth Authorization is not configured in the SDK.");
            }

            _accessTokenType = "oauth";
        }
		
		public void UseDefaultAuth()
		{
			_accessTokenType = string.Empty;
		}

        public string GetBaseUrl()
		{
			if (_accessTokenType == "api" && _sdkConfig.UseApiAuthorization)
			{
				return _sdkConfig.ApiAuthUrl;
			}

			if ((_accessTokenType == "oauth" || string.IsNullOrEmpty(_accessTokenType)) && _sdkConfig.UseOAuthAuthorization)
			{
				return _sdkConfig.OAuthUrl;
			}
			
			throw new Exception("No valid authorization mode is configured or enabled.");
		}
		
		

        partial void FormatBackgroundJobsBackgroundJobCancelBackgroundJob(ref Option<Guid> id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterBackgroundJobsBackgroundJobCancelBackgroundJobDefaultImplementation(IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse apiResponseLocalVar, Option<Guid> id)
        {
            bool suppressDefaultLog = false;
            AfterBackgroundJobsBackgroundJobCancelBackgroundJob(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterBackgroundJobsBackgroundJobCancelBackgroundJob(ref bool suppressDefaultLog, IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse apiResponseLocalVar, Option<Guid> id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        private void OnErrorBackgroundJobsBackgroundJobCancelBackgroundJobDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> id)
        {
            bool suppressDefaultLog = false;
            OnErrorBackgroundJobsBackgroundJobCancelBackgroundJob(ref suppressDefaultLog, exception, pathFormat, path, id);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        partial void OnErrorBackgroundJobsBackgroundJobCancelBackgroundJob(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> id);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse> BackgroundJobsBackgroundJobCancelBackgroundJobOrDefaultAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BackgroundJobsBackgroundJobCancelBackgroundJobAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse> BackgroundJobsBackgroundJobCancelBackgroundJobAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "BackgroundJobApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatBackgroundJobsBackgroundJobCancelBackgroundJob(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/BackgroundJob/BackgroundJobs/CancelBackgroundJob";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<BackgroundJobsBackgroundJobCancelBackgroundJobApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BackgroundJobsBackgroundJobCancelBackgroundJobApiResponse>();

                        BackgroundJobsBackgroundJobCancelBackgroundJobApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/BackgroundJob/BackgroundJobs/CancelBackgroundJob", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterBackgroundJobsBackgroundJobCancelBackgroundJobDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnBackgroundJobsBackgroundJobCancelBackgroundJob(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBackgroundJobsBackgroundJobCancelBackgroundJobDefaultImplementation(e, "/api/BackgroundJob/BackgroundJobs/CancelBackgroundJob", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorBackgroundJobsBackgroundJobCancelBackgroundJob(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BackgroundJobsBackgroundJobCancelBackgroundJobApiResponse"/>
        /// </summary>
        public partial class BackgroundJobsBackgroundJobCancelBackgroundJobApiResponse : EleonsoftProxy.Client.ApiResponse, IBackgroundJobsBackgroundJobCancelBackgroundJobApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BackgroundJobsBackgroundJobCancelBackgroundJobApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BackgroundJobsBackgroundJobCancelBackgroundJobApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BackgroundJobsBackgroundJobCancelBackgroundJobApiResponse(ILogger<BackgroundJobsBackgroundJobCancelBackgroundJobApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBackgroundJobsBackgroundJobComplete(Option<BackgroundJobsBackgroundJobExecutionCompleteDto> backgroundJobsBackgroundJobExecutionCompleteDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="backgroundJobsBackgroundJobExecutionCompleteDto"></param>
        /// <returns></returns>
        private void ValidateBackgroundJobsBackgroundJobComplete(Option<BackgroundJobsBackgroundJobExecutionCompleteDto> backgroundJobsBackgroundJobExecutionCompleteDto)
        {
            if (backgroundJobsBackgroundJobExecutionCompleteDto.IsSet && backgroundJobsBackgroundJobExecutionCompleteDto.Value == null)
                throw new ArgumentNullException(nameof(backgroundJobsBackgroundJobExecutionCompleteDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="backgroundJobsBackgroundJobExecutionCompleteDto"></param>
        private void AfterBackgroundJobsBackgroundJobCompleteDefaultImplementation(IBackgroundJobsBackgroundJobCompleteApiResponse apiResponseLocalVar, Option<BackgroundJobsBackgroundJobExecutionCompleteDto> backgroundJobsBackgroundJobExecutionCompleteDto)
        {
            bool suppressDefaultLog = false;
            AfterBackgroundJobsBackgroundJobComplete(ref suppressDefaultLog, apiResponseLocalVar, backgroundJobsBackgroundJobExecutionCompleteDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="backgroundJobsBackgroundJobExecutionCompleteDto"></param>
        partial void AfterBackgroundJobsBackgroundJobComplete(ref bool suppressDefaultLog, IBackgroundJobsBackgroundJobCompleteApiResponse apiResponseLocalVar, Option<BackgroundJobsBackgroundJobExecutionCompleteDto> backgroundJobsBackgroundJobExecutionCompleteDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="backgroundJobsBackgroundJobExecutionCompleteDto"></param>
        private void OnErrorBackgroundJobsBackgroundJobCompleteDefaultImplementation(Exception exception, string pathFormat, string path, Option<BackgroundJobsBackgroundJobExecutionCompleteDto> backgroundJobsBackgroundJobExecutionCompleteDto)
        {
            bool suppressDefaultLog = false;
            OnErrorBackgroundJobsBackgroundJobComplete(ref suppressDefaultLog, exception, pathFormat, path, backgroundJobsBackgroundJobExecutionCompleteDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="backgroundJobsBackgroundJobExecutionCompleteDto"></param>
        partial void OnErrorBackgroundJobsBackgroundJobComplete(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<BackgroundJobsBackgroundJobExecutionCompleteDto> backgroundJobsBackgroundJobExecutionCompleteDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="backgroundJobsBackgroundJobExecutionCompleteDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCompleteApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobCompleteApiResponse> BackgroundJobsBackgroundJobCompleteOrDefaultAsync(Option<BackgroundJobsBackgroundJobExecutionCompleteDto> backgroundJobsBackgroundJobExecutionCompleteDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BackgroundJobsBackgroundJobCompleteAsync(backgroundJobsBackgroundJobExecutionCompleteDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="backgroundJobsBackgroundJobExecutionCompleteDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCompleteApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobCompleteApiResponse> BackgroundJobsBackgroundJobCompleteAsync(Option<BackgroundJobsBackgroundJobExecutionCompleteDto> backgroundJobsBackgroundJobExecutionCompleteDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "BackgroundJobApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateBackgroundJobsBackgroundJobComplete(backgroundJobsBackgroundJobExecutionCompleteDto);

                FormatBackgroundJobsBackgroundJobComplete(backgroundJobsBackgroundJobExecutionCompleteDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/BackgroundJob/BackgroundJobs/Complete";


                    if (backgroundJobsBackgroundJobExecutionCompleteDto.IsSet)
                        httpRequestMessageLocalVar.Content = (backgroundJobsBackgroundJobExecutionCompleteDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(backgroundJobsBackgroundJobExecutionCompleteDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<BackgroundJobsBackgroundJobCompleteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BackgroundJobsBackgroundJobCompleteApiResponse>();

                        BackgroundJobsBackgroundJobCompleteApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/BackgroundJob/BackgroundJobs/Complete", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterBackgroundJobsBackgroundJobCompleteDefaultImplementation(apiResponseLocalVar, backgroundJobsBackgroundJobExecutionCompleteDto);

                        Events.ExecuteOnBackgroundJobsBackgroundJobComplete(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBackgroundJobsBackgroundJobCompleteDefaultImplementation(e, "/api/BackgroundJob/BackgroundJobs/Complete", uriBuilderLocalVar.Path, backgroundJobsBackgroundJobExecutionCompleteDto);
                Events.ExecuteOnErrorBackgroundJobsBackgroundJobComplete(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BackgroundJobsBackgroundJobCompleteApiResponse"/>
        /// </summary>
        public partial class BackgroundJobsBackgroundJobCompleteApiResponse : EleonsoftProxy.Client.ApiResponse, IBackgroundJobsBackgroundJobCompleteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BackgroundJobsBackgroundJobCompleteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BackgroundJobsBackgroundJobCompleteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BackgroundJobsBackgroundJobCompleteApiResponse(ILogger<BackgroundJobsBackgroundJobCompleteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.BackgroundJobsBackgroundJobDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.BackgroundJobsBackgroundJobDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleonsoftProxy.Model.BackgroundJobsBackgroundJobDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBackgroundJobsBackgroundJobCreate(Option<BackgroundJobsCreateBackgroundJobDto> backgroundJobsCreateBackgroundJobDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="backgroundJobsCreateBackgroundJobDto"></param>
        /// <returns></returns>
        private void ValidateBackgroundJobsBackgroundJobCreate(Option<BackgroundJobsCreateBackgroundJobDto> backgroundJobsCreateBackgroundJobDto)
        {
            if (backgroundJobsCreateBackgroundJobDto.IsSet && backgroundJobsCreateBackgroundJobDto.Value == null)
                throw new ArgumentNullException(nameof(backgroundJobsCreateBackgroundJobDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="backgroundJobsCreateBackgroundJobDto"></param>
        private void AfterBackgroundJobsBackgroundJobCreateDefaultImplementation(IBackgroundJobsBackgroundJobCreateApiResponse apiResponseLocalVar, Option<BackgroundJobsCreateBackgroundJobDto> backgroundJobsCreateBackgroundJobDto)
        {
            bool suppressDefaultLog = false;
            AfterBackgroundJobsBackgroundJobCreate(ref suppressDefaultLog, apiResponseLocalVar, backgroundJobsCreateBackgroundJobDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="backgroundJobsCreateBackgroundJobDto"></param>
        partial void AfterBackgroundJobsBackgroundJobCreate(ref bool suppressDefaultLog, IBackgroundJobsBackgroundJobCreateApiResponse apiResponseLocalVar, Option<BackgroundJobsCreateBackgroundJobDto> backgroundJobsCreateBackgroundJobDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="backgroundJobsCreateBackgroundJobDto"></param>
        private void OnErrorBackgroundJobsBackgroundJobCreateDefaultImplementation(Exception exception, string pathFormat, string path, Option<BackgroundJobsCreateBackgroundJobDto> backgroundJobsCreateBackgroundJobDto)
        {
            bool suppressDefaultLog = false;
            OnErrorBackgroundJobsBackgroundJobCreate(ref suppressDefaultLog, exception, pathFormat, path, backgroundJobsCreateBackgroundJobDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="backgroundJobsCreateBackgroundJobDto"></param>
        partial void OnErrorBackgroundJobsBackgroundJobCreate(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<BackgroundJobsCreateBackgroundJobDto> backgroundJobsCreateBackgroundJobDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="backgroundJobsCreateBackgroundJobDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCreateApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobCreateApiResponse> BackgroundJobsBackgroundJobCreateOrDefaultAsync(Option<BackgroundJobsCreateBackgroundJobDto> backgroundJobsCreateBackgroundJobDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BackgroundJobsBackgroundJobCreateAsync(backgroundJobsCreateBackgroundJobDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="backgroundJobsCreateBackgroundJobDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobCreateApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobCreateApiResponse> BackgroundJobsBackgroundJobCreateAsync(Option<BackgroundJobsCreateBackgroundJobDto> backgroundJobsCreateBackgroundJobDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "BackgroundJobApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateBackgroundJobsBackgroundJobCreate(backgroundJobsCreateBackgroundJobDto);

                FormatBackgroundJobsBackgroundJobCreate(backgroundJobsCreateBackgroundJobDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/BackgroundJob/BackgroundJobs/Create";


                    if (backgroundJobsCreateBackgroundJobDto.IsSet)
                        httpRequestMessageLocalVar.Content = (backgroundJobsCreateBackgroundJobDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(backgroundJobsCreateBackgroundJobDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<BackgroundJobsBackgroundJobCreateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BackgroundJobsBackgroundJobCreateApiResponse>();

                        BackgroundJobsBackgroundJobCreateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/BackgroundJob/BackgroundJobs/Create", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterBackgroundJobsBackgroundJobCreateDefaultImplementation(apiResponseLocalVar, backgroundJobsCreateBackgroundJobDto);

                        Events.ExecuteOnBackgroundJobsBackgroundJobCreate(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBackgroundJobsBackgroundJobCreateDefaultImplementation(e, "/api/BackgroundJob/BackgroundJobs/Create", uriBuilderLocalVar.Path, backgroundJobsCreateBackgroundJobDto);
                Events.ExecuteOnErrorBackgroundJobsBackgroundJobCreate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BackgroundJobsBackgroundJobCreateApiResponse"/>
        /// </summary>
        public partial class BackgroundJobsBackgroundJobCreateApiResponse : EleonsoftProxy.Client.ApiResponse, IBackgroundJobsBackgroundJobCreateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BackgroundJobsBackgroundJobCreateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BackgroundJobsBackgroundJobCreateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BackgroundJobsBackgroundJobCreateApiResponse(ILogger<BackgroundJobsBackgroundJobCreateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.BackgroundJobsBackgroundJobDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.BackgroundJobsBackgroundJobDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleonsoftProxy.Model.BackgroundJobsBackgroundJobDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBackgroundJobsBackgroundJobGetBackgroundJobById(ref Option<Guid> id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterBackgroundJobsBackgroundJobGetBackgroundJobByIdDefaultImplementation(IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse apiResponseLocalVar, Option<Guid> id)
        {
            bool suppressDefaultLog = false;
            AfterBackgroundJobsBackgroundJobGetBackgroundJobById(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterBackgroundJobsBackgroundJobGetBackgroundJobById(ref bool suppressDefaultLog, IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse apiResponseLocalVar, Option<Guid> id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        private void OnErrorBackgroundJobsBackgroundJobGetBackgroundJobByIdDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> id)
        {
            bool suppressDefaultLog = false;
            OnErrorBackgroundJobsBackgroundJobGetBackgroundJobById(ref suppressDefaultLog, exception, pathFormat, path, id);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        partial void OnErrorBackgroundJobsBackgroundJobGetBackgroundJobById(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> id);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse> BackgroundJobsBackgroundJobGetBackgroundJobByIdOrDefaultAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BackgroundJobsBackgroundJobGetBackgroundJobByIdAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse> BackgroundJobsBackgroundJobGetBackgroundJobByIdAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "BackgroundJobApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatBackgroundJobsBackgroundJobGetBackgroundJobById(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/BackgroundJob/BackgroundJobs/GetBackgroundJobById";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<BackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse>();

                        BackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/BackgroundJob/BackgroundJobs/GetBackgroundJobById", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterBackgroundJobsBackgroundJobGetBackgroundJobByIdDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnBackgroundJobsBackgroundJobGetBackgroundJobById(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBackgroundJobsBackgroundJobGetBackgroundJobByIdDefaultImplementation(e, "/api/BackgroundJob/BackgroundJobs/GetBackgroundJobById", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorBackgroundJobsBackgroundJobGetBackgroundJobById(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse"/>
        /// </summary>
        public partial class BackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse : EleonsoftProxy.Client.ApiResponse, IBackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse(ILogger<BackgroundJobsBackgroundJobGetBackgroundJobByIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.BackgroundJobsFullBackgroundJobDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.BackgroundJobsFullBackgroundJobDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleonsoftProxy.Model.BackgroundJobsFullBackgroundJobDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBackgroundJobsBackgroundJobGetBackgroundJobList(ref Option<string> searchQuery, Option<List<EleoncoreBackgroundJobStatus>> statusFilter, Option<List<string>> objectTypeFilter, Option<List<string>> typeFilter, ref Option<DateTime> creationDateFilterStart, ref Option<DateTime> creationDateFilterEnd, ref Option<DateTime> lastExecutionDateFilterStart, ref Option<DateTime> lastExecutionDateFilterEnd, ref Option<string> sorting, ref Option<int> skipCount, ref Option<int> maxResultCount);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="searchQuery"></param>
        /// <param name="statusFilter"></param>
        /// <param name="objectTypeFilter"></param>
        /// <param name="typeFilter"></param>
        /// <param name="sorting"></param>
        /// <returns></returns>
        private void ValidateBackgroundJobsBackgroundJobGetBackgroundJobList(Option<string> searchQuery, Option<List<EleoncoreBackgroundJobStatus>> statusFilter, Option<List<string>> objectTypeFilter, Option<List<string>> typeFilter, Option<string> sorting)
        {
            if (searchQuery.IsSet && searchQuery.Value == null)
                throw new ArgumentNullException(nameof(searchQuery));

            if (statusFilter.IsSet && statusFilter.Value == null)
                throw new ArgumentNullException(nameof(statusFilter));

            if (objectTypeFilter.IsSet && objectTypeFilter.Value == null)
                throw new ArgumentNullException(nameof(objectTypeFilter));

            if (typeFilter.IsSet && typeFilter.Value == null)
                throw new ArgumentNullException(nameof(typeFilter));

            if (sorting.IsSet && sorting.Value == null)
                throw new ArgumentNullException(nameof(sorting));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="searchQuery"></param>
        /// <param name="statusFilter"></param>
        /// <param name="objectTypeFilter"></param>
        /// <param name="typeFilter"></param>
        /// <param name="creationDateFilterStart"></param>
        /// <param name="creationDateFilterEnd"></param>
        /// <param name="lastExecutionDateFilterStart"></param>
        /// <param name="lastExecutionDateFilterEnd"></param>
        /// <param name="sorting"></param>
        /// <param name="skipCount"></param>
        /// <param name="maxResultCount"></param>
        private void AfterBackgroundJobsBackgroundJobGetBackgroundJobListDefaultImplementation(IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse apiResponseLocalVar, Option<string> searchQuery, Option<List<EleoncoreBackgroundJobStatus>> statusFilter, Option<List<string>> objectTypeFilter, Option<List<string>> typeFilter, Option<DateTime> creationDateFilterStart, Option<DateTime> creationDateFilterEnd, Option<DateTime> lastExecutionDateFilterStart, Option<DateTime> lastExecutionDateFilterEnd, Option<string> sorting, Option<int> skipCount, Option<int> maxResultCount)
        {
            bool suppressDefaultLog = false;
            AfterBackgroundJobsBackgroundJobGetBackgroundJobList(ref suppressDefaultLog, apiResponseLocalVar, searchQuery, statusFilter, objectTypeFilter, typeFilter, creationDateFilterStart, creationDateFilterEnd, lastExecutionDateFilterStart, lastExecutionDateFilterEnd, sorting, skipCount, maxResultCount);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="searchQuery"></param>
        /// <param name="statusFilter"></param>
        /// <param name="objectTypeFilter"></param>
        /// <param name="typeFilter"></param>
        /// <param name="creationDateFilterStart"></param>
        /// <param name="creationDateFilterEnd"></param>
        /// <param name="lastExecutionDateFilterStart"></param>
        /// <param name="lastExecutionDateFilterEnd"></param>
        /// <param name="sorting"></param>
        /// <param name="skipCount"></param>
        /// <param name="maxResultCount"></param>
        partial void AfterBackgroundJobsBackgroundJobGetBackgroundJobList(ref bool suppressDefaultLog, IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse apiResponseLocalVar, Option<string> searchQuery, Option<List<EleoncoreBackgroundJobStatus>> statusFilter, Option<List<string>> objectTypeFilter, Option<List<string>> typeFilter, Option<DateTime> creationDateFilterStart, Option<DateTime> creationDateFilterEnd, Option<DateTime> lastExecutionDateFilterStart, Option<DateTime> lastExecutionDateFilterEnd, Option<string> sorting, Option<int> skipCount, Option<int> maxResultCount);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="searchQuery"></param>
        /// <param name="statusFilter"></param>
        /// <param name="objectTypeFilter"></param>
        /// <param name="typeFilter"></param>
        /// <param name="creationDateFilterStart"></param>
        /// <param name="creationDateFilterEnd"></param>
        /// <param name="lastExecutionDateFilterStart"></param>
        /// <param name="lastExecutionDateFilterEnd"></param>
        /// <param name="sorting"></param>
        /// <param name="skipCount"></param>
        /// <param name="maxResultCount"></param>
        private void OnErrorBackgroundJobsBackgroundJobGetBackgroundJobListDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> searchQuery, Option<List<EleoncoreBackgroundJobStatus>> statusFilter, Option<List<string>> objectTypeFilter, Option<List<string>> typeFilter, Option<DateTime> creationDateFilterStart, Option<DateTime> creationDateFilterEnd, Option<DateTime> lastExecutionDateFilterStart, Option<DateTime> lastExecutionDateFilterEnd, Option<string> sorting, Option<int> skipCount, Option<int> maxResultCount)
        {
            bool suppressDefaultLog = false;
            OnErrorBackgroundJobsBackgroundJobGetBackgroundJobList(ref suppressDefaultLog, exception, pathFormat, path, searchQuery, statusFilter, objectTypeFilter, typeFilter, creationDateFilterStart, creationDateFilterEnd, lastExecutionDateFilterStart, lastExecutionDateFilterEnd, sorting, skipCount, maxResultCount);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="searchQuery"></param>
        /// <param name="statusFilter"></param>
        /// <param name="objectTypeFilter"></param>
        /// <param name="typeFilter"></param>
        /// <param name="creationDateFilterStart"></param>
        /// <param name="creationDateFilterEnd"></param>
        /// <param name="lastExecutionDateFilterStart"></param>
        /// <param name="lastExecutionDateFilterEnd"></param>
        /// <param name="sorting"></param>
        /// <param name="skipCount"></param>
        /// <param name="maxResultCount"></param>
        partial void OnErrorBackgroundJobsBackgroundJobGetBackgroundJobList(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> searchQuery, Option<List<EleoncoreBackgroundJobStatus>> statusFilter, Option<List<string>> objectTypeFilter, Option<List<string>> typeFilter, Option<DateTime> creationDateFilterStart, Option<DateTime> creationDateFilterEnd, Option<DateTime> lastExecutionDateFilterStart, Option<DateTime> lastExecutionDateFilterEnd, Option<string> sorting, Option<int> skipCount, Option<int> maxResultCount);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="searchQuery"> (optional)</param>
        /// <param name="statusFilter"> (optional)</param>
        /// <param name="objectTypeFilter"> (optional)</param>
        /// <param name="typeFilter"> (optional)</param>
        /// <param name="creationDateFilterStart"> (optional)</param>
        /// <param name="creationDateFilterEnd"> (optional)</param>
        /// <param name="lastExecutionDateFilterStart"> (optional)</param>
        /// <param name="lastExecutionDateFilterEnd"> (optional)</param>
        /// <param name="sorting"> (optional)</param>
        /// <param name="skipCount"> (optional)</param>
        /// <param name="maxResultCount"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse> BackgroundJobsBackgroundJobGetBackgroundJobListOrDefaultAsync(Option<string> searchQuery = default, Option<List<EleoncoreBackgroundJobStatus>> statusFilter = default, Option<List<string>> objectTypeFilter = default, Option<List<string>> typeFilter = default, Option<DateTime> creationDateFilterStart = default, Option<DateTime> creationDateFilterEnd = default, Option<DateTime> lastExecutionDateFilterStart = default, Option<DateTime> lastExecutionDateFilterEnd = default, Option<string> sorting = default, Option<int> skipCount = default, Option<int> maxResultCount = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BackgroundJobsBackgroundJobGetBackgroundJobListAsync(searchQuery, statusFilter, objectTypeFilter, typeFilter, creationDateFilterStart, creationDateFilterEnd, lastExecutionDateFilterStart, lastExecutionDateFilterEnd, sorting, skipCount, maxResultCount, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchQuery"> (optional)</param>
        /// <param name="statusFilter"> (optional)</param>
        /// <param name="objectTypeFilter"> (optional)</param>
        /// <param name="typeFilter"> (optional)</param>
        /// <param name="creationDateFilterStart"> (optional)</param>
        /// <param name="creationDateFilterEnd"> (optional)</param>
        /// <param name="lastExecutionDateFilterStart"> (optional)</param>
        /// <param name="lastExecutionDateFilterEnd"> (optional)</param>
        /// <param name="sorting"> (optional)</param>
        /// <param name="skipCount"> (optional)</param>
        /// <param name="maxResultCount"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse> BackgroundJobsBackgroundJobGetBackgroundJobListAsync(Option<string> searchQuery = default, Option<List<EleoncoreBackgroundJobStatus>> statusFilter = default, Option<List<string>> objectTypeFilter = default, Option<List<string>> typeFilter = default, Option<DateTime> creationDateFilterStart = default, Option<DateTime> creationDateFilterEnd = default, Option<DateTime> lastExecutionDateFilterStart = default, Option<DateTime> lastExecutionDateFilterEnd = default, Option<string> sorting = default, Option<int> skipCount = default, Option<int> maxResultCount = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "BackgroundJobApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateBackgroundJobsBackgroundJobGetBackgroundJobList(searchQuery, statusFilter, objectTypeFilter, typeFilter, sorting);

                FormatBackgroundJobsBackgroundJobGetBackgroundJobList(ref searchQuery, statusFilter, objectTypeFilter, typeFilter, ref creationDateFilterStart, ref creationDateFilterEnd, ref lastExecutionDateFilterStart, ref lastExecutionDateFilterEnd, ref sorting, ref skipCount, ref maxResultCount);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/BackgroundJob/BackgroundJobs/GetBackgroundJobList";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (searchQuery.IsSet)
                        parseQueryStringLocalVar["searchQuery"] = ClientUtils.ParameterToString(searchQuery.Value);

                    if (statusFilter.IsSet)
                        parseQueryStringLocalVar["statusFilter"] = ClientUtils.ParameterToString(statusFilter.Value);

                    if (objectTypeFilter.IsSet)
                        parseQueryStringLocalVar["objectTypeFilter"] = ClientUtils.ParameterToString(objectTypeFilter.Value);

                    if (typeFilter.IsSet)
                        parseQueryStringLocalVar["typeFilter"] = ClientUtils.ParameterToString(typeFilter.Value);

                    if (creationDateFilterStart.IsSet)
                        parseQueryStringLocalVar["creationDateFilterStart"] = ClientUtils.ParameterToString(creationDateFilterStart.Value);

                    if (creationDateFilterEnd.IsSet)
                        parseQueryStringLocalVar["creationDateFilterEnd"] = ClientUtils.ParameterToString(creationDateFilterEnd.Value);

                    if (lastExecutionDateFilterStart.IsSet)
                        parseQueryStringLocalVar["lastExecutionDateFilterStart"] = ClientUtils.ParameterToString(lastExecutionDateFilterStart.Value);

                    if (lastExecutionDateFilterEnd.IsSet)
                        parseQueryStringLocalVar["lastExecutionDateFilterEnd"] = ClientUtils.ParameterToString(lastExecutionDateFilterEnd.Value);

                    if (sorting.IsSet)
                        parseQueryStringLocalVar["sorting"] = ClientUtils.ParameterToString(sorting.Value);

                    if (skipCount.IsSet)
                        parseQueryStringLocalVar["skipCount"] = ClientUtils.ParameterToString(skipCount.Value);

                    if (maxResultCount.IsSet)
                        parseQueryStringLocalVar["maxResultCount"] = ClientUtils.ParameterToString(maxResultCount.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<BackgroundJobsBackgroundJobGetBackgroundJobListApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BackgroundJobsBackgroundJobGetBackgroundJobListApiResponse>();

                        BackgroundJobsBackgroundJobGetBackgroundJobListApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/BackgroundJob/BackgroundJobs/GetBackgroundJobList", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterBackgroundJobsBackgroundJobGetBackgroundJobListDefaultImplementation(apiResponseLocalVar, searchQuery, statusFilter, objectTypeFilter, typeFilter, creationDateFilterStart, creationDateFilterEnd, lastExecutionDateFilterStart, lastExecutionDateFilterEnd, sorting, skipCount, maxResultCount);

                        Events.ExecuteOnBackgroundJobsBackgroundJobGetBackgroundJobList(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBackgroundJobsBackgroundJobGetBackgroundJobListDefaultImplementation(e, "/api/BackgroundJob/BackgroundJobs/GetBackgroundJobList", uriBuilderLocalVar.Path, searchQuery, statusFilter, objectTypeFilter, typeFilter, creationDateFilterStart, creationDateFilterEnd, lastExecutionDateFilterStart, lastExecutionDateFilterEnd, sorting, skipCount, maxResultCount);
                Events.ExecuteOnErrorBackgroundJobsBackgroundJobGetBackgroundJobList(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BackgroundJobsBackgroundJobGetBackgroundJobListApiResponse"/>
        /// </summary>
        public partial class BackgroundJobsBackgroundJobGetBackgroundJobListApiResponse : EleonsoftProxy.Client.ApiResponse, IBackgroundJobsBackgroundJobGetBackgroundJobListApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BackgroundJobsBackgroundJobGetBackgroundJobListApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BackgroundJobsBackgroundJobGetBackgroundJobListApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BackgroundJobsBackgroundJobGetBackgroundJobListApiResponse(ILogger<BackgroundJobsBackgroundJobGetBackgroundJobListApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncorePagedResultDtoOfBackgroundJobsBackgroundJobHeaderDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncorePagedResultDtoOfBackgroundJobsBackgroundJobHeaderDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncorePagedResultDtoOfBackgroundJobsBackgroundJobHeaderDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBackgroundJobsBackgroundJobMarkExecutionStarted(ref Option<Guid> jobId, ref Option<Guid> executionId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="jobId"></param>
        /// <param name="executionId"></param>
        private void AfterBackgroundJobsBackgroundJobMarkExecutionStartedDefaultImplementation(IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse apiResponseLocalVar, Option<Guid> jobId, Option<Guid> executionId)
        {
            bool suppressDefaultLog = false;
            AfterBackgroundJobsBackgroundJobMarkExecutionStarted(ref suppressDefaultLog, apiResponseLocalVar, jobId, executionId);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="jobId"></param>
        /// <param name="executionId"></param>
        partial void AfterBackgroundJobsBackgroundJobMarkExecutionStarted(ref bool suppressDefaultLog, IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse apiResponseLocalVar, Option<Guid> jobId, Option<Guid> executionId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="jobId"></param>
        /// <param name="executionId"></param>
        private void OnErrorBackgroundJobsBackgroundJobMarkExecutionStartedDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> jobId, Option<Guid> executionId)
        {
            bool suppressDefaultLog = false;
            OnErrorBackgroundJobsBackgroundJobMarkExecutionStarted(ref suppressDefaultLog, exception, pathFormat, path, jobId, executionId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="jobId"></param>
        /// <param name="executionId"></param>
        partial void OnErrorBackgroundJobsBackgroundJobMarkExecutionStarted(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> jobId, Option<Guid> executionId);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="jobId"> (optional)</param>
        /// <param name="executionId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse> BackgroundJobsBackgroundJobMarkExecutionStartedOrDefaultAsync(Option<Guid> jobId = default, Option<Guid> executionId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BackgroundJobsBackgroundJobMarkExecutionStartedAsync(jobId, executionId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"> (optional)</param>
        /// <param name="executionId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse> BackgroundJobsBackgroundJobMarkExecutionStartedAsync(Option<Guid> jobId = default, Option<Guid> executionId = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "BackgroundJobApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatBackgroundJobsBackgroundJobMarkExecutionStarted(ref jobId, ref executionId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/BackgroundJob/BackgroundJobs/MarkExecutionStarted";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (jobId.IsSet)
                        parseQueryStringLocalVar["jobId"] = ClientUtils.ParameterToString(jobId.Value);

                    if (executionId.IsSet)
                        parseQueryStringLocalVar["executionId"] = ClientUtils.ParameterToString(executionId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<BackgroundJobsBackgroundJobMarkExecutionStartedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BackgroundJobsBackgroundJobMarkExecutionStartedApiResponse>();

                        BackgroundJobsBackgroundJobMarkExecutionStartedApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/BackgroundJob/BackgroundJobs/MarkExecutionStarted", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterBackgroundJobsBackgroundJobMarkExecutionStartedDefaultImplementation(apiResponseLocalVar, jobId, executionId);

                        Events.ExecuteOnBackgroundJobsBackgroundJobMarkExecutionStarted(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBackgroundJobsBackgroundJobMarkExecutionStartedDefaultImplementation(e, "/api/BackgroundJob/BackgroundJobs/MarkExecutionStarted", uriBuilderLocalVar.Path, jobId, executionId);
                Events.ExecuteOnErrorBackgroundJobsBackgroundJobMarkExecutionStarted(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BackgroundJobsBackgroundJobMarkExecutionStartedApiResponse"/>
        /// </summary>
        public partial class BackgroundJobsBackgroundJobMarkExecutionStartedApiResponse : EleonsoftProxy.Client.ApiResponse, IBackgroundJobsBackgroundJobMarkExecutionStartedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BackgroundJobsBackgroundJobMarkExecutionStartedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BackgroundJobsBackgroundJobMarkExecutionStartedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BackgroundJobsBackgroundJobMarkExecutionStartedApiResponse(ILogger<BackgroundJobsBackgroundJobMarkExecutionStartedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBackgroundJobsBackgroundJobRetryBackgroundJob(ref Option<Guid> id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterBackgroundJobsBackgroundJobRetryBackgroundJobDefaultImplementation(IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse apiResponseLocalVar, Option<Guid> id)
        {
            bool suppressDefaultLog = false;
            AfterBackgroundJobsBackgroundJobRetryBackgroundJob(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterBackgroundJobsBackgroundJobRetryBackgroundJob(ref bool suppressDefaultLog, IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse apiResponseLocalVar, Option<Guid> id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        private void OnErrorBackgroundJobsBackgroundJobRetryBackgroundJobDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> id)
        {
            bool suppressDefaultLog = false;
            OnErrorBackgroundJobsBackgroundJobRetryBackgroundJob(ref suppressDefaultLog, exception, pathFormat, path, id);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        partial void OnErrorBackgroundJobsBackgroundJobRetryBackgroundJob(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> id);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse> BackgroundJobsBackgroundJobRetryBackgroundJobOrDefaultAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BackgroundJobsBackgroundJobRetryBackgroundJobAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse"/>&gt;</returns>
        public async Task<IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse> BackgroundJobsBackgroundJobRetryBackgroundJobAsync(Option<Guid> id = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "BackgroundJobApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatBackgroundJobsBackgroundJobRetryBackgroundJob(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/BackgroundJob/BackgroundJobs/RetryBackgroundJob";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<BackgroundJobsBackgroundJobRetryBackgroundJobApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BackgroundJobsBackgroundJobRetryBackgroundJobApiResponse>();

                        BackgroundJobsBackgroundJobRetryBackgroundJobApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/BackgroundJob/BackgroundJobs/RetryBackgroundJob", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterBackgroundJobsBackgroundJobRetryBackgroundJobDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnBackgroundJobsBackgroundJobRetryBackgroundJob(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBackgroundJobsBackgroundJobRetryBackgroundJobDefaultImplementation(e, "/api/BackgroundJob/BackgroundJobs/RetryBackgroundJob", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorBackgroundJobsBackgroundJobRetryBackgroundJob(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BackgroundJobsBackgroundJobRetryBackgroundJobApiResponse"/>
        /// </summary>
        public partial class BackgroundJobsBackgroundJobRetryBackgroundJobApiResponse : EleonsoftProxy.Client.ApiResponse, IBackgroundJobsBackgroundJobRetryBackgroundJobApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BackgroundJobsBackgroundJobRetryBackgroundJobApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BackgroundJobsBackgroundJobRetryBackgroundJobApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BackgroundJobsBackgroundJobRetryBackgroundJobApiResponse(ILogger<BackgroundJobsBackgroundJobRetryBackgroundJobApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}

