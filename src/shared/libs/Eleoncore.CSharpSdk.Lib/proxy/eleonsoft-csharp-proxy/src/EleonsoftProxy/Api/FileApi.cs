// <auto-generated>
/*
 * Admin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using SharedModule.HttpApi.Helpers;
using Microsoft.AspNetCore.Http;
using EleonsoftProxy.Client;
using EleonsoftProxy.Model;
using System.Diagnostics.CodeAnalysis;

namespace EleonsoftProxy.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IFileApi : IApi
    {
        void UseOAuthAuth();
        void UseApiAuth();
		void UseDefaultAuth();


        /// <summary>
        /// The class containing the events
        /// </summary>
        FileApiEvents Events { get; }

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerCopyEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileCopyEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileCopyEntryApiResponse> FileManagerFileCopyEntryAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerCopyEntryDto> fileManagerCopyEntryDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerCopyEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileCopyEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileCopyEntryApiResponse> FileManagerFileCopyEntryOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerCopyEntryDto> fileManagerCopyEntryDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerCreateEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileCreateEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileCreateEntryApiResponse> FileManagerFileCreateEntryAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerCreateEntryDto> fileManagerCreateEntryDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerCreateEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileCreateEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileCreateEntryApiResponse> FileManagerFileCreateEntryOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerCreateEntryDto> fileManagerCreateEntryDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDeleteEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileDeleteEntryApiResponse> FileManagerFileDeleteEntryAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDeleteEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileDeleteEntryApiResponse> FileManagerFileDeleteEntryOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="token"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDeleteFileTokenApiResponse"/>&gt;</returns>
        Task<IFileManagerFileDeleteFileTokenApiResponse> FileManagerFileDeleteFileTokenAsync(Option<Guid> token = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="token"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDeleteFileTokenApiResponse"/>&gt;</returns>
        Task<IFileManagerFileDeleteFileTokenApiResponse> FileManagerFileDeleteFileTokenOrDefaultAsync(Option<Guid> token = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileManagerDownloadAllDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadAllApiResponse"/>&gt;</returns>
        Task<IFileManagerFileDownloadAllApiResponse> FileManagerFileDownloadAllAsync(Option<FileManagerDownloadAllDto> fileManagerDownloadAllDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="fileManagerDownloadAllDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadAllApiResponse"/>&gt;</returns>
        Task<IFileManagerFileDownloadAllApiResponse> FileManagerFileDownloadAllOrDefaultAsync(Option<FileManagerDownloadAllDto> fileManagerDownloadAllDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadFileApiResponse"/>&gt;</returns>
        Task<IFileManagerFileDownloadFileApiResponse> FileManagerFileDownloadFileAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadFileApiResponse"/>&gt;</returns>
        Task<IFileManagerFileDownloadFileApiResponse> FileManagerFileDownloadFileOrDefaultAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadFileByTokenApiResponse"/>&gt;</returns>
        Task<IFileManagerFileDownloadFileByTokenApiResponse> FileManagerFileDownloadFileByTokenAsync(Option<string> id = default, Option<string> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadFileByTokenApiResponse"/>&gt;</returns>
        Task<IFileManagerFileDownloadFileByTokenApiResponse> FileManagerFileDownloadFileByTokenOrDefaultAsync(Option<string> id = default, Option<string> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileFileViewerApiResponse"/>&gt;</returns>
        Task<IFileManagerFileFileViewerApiResponse> FileManagerFileFileViewerAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileFileViewerApiResponse"/>&gt;</returns>
        Task<IFileManagerFileFileViewerApiResponse> FileManagerFileFileViewerOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileManagerEntryFilterDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntriesApiResponse> FileManagerFileGetEntriesAsync(Option<FileManagerEntryFilterDto> fileManagerEntryFilterDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="fileManagerEntryFilterDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntriesApiResponse> FileManagerFileGetEntriesOrDefaultAsync(Option<FileManagerEntryFilterDto> fileManagerEntryFilterDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="requestBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByIdsApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntriesByIdsApiResponse> FileManagerFileGetEntriesByIdsAsync(Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<List<string>> requestBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="requestBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByIdsApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntriesByIdsApiResponse> FileManagerFileGetEntriesByIdsOrDefaultAsync(Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<List<string>> requestBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="parentId"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="fileStatuses"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="recursive"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByParentIdApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntriesByParentIdApiResponse> FileManagerFileGetEntriesByParentIdAsync(Option<string> parentId = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<List<EleoncoreFileStatus>> fileStatuses = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<bool> recursive = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="parentId"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="fileStatuses"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="recursive"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByParentIdApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntriesByParentIdApiResponse> FileManagerFileGetEntriesByParentIdOrDefaultAsync(Option<string> parentId = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<List<EleoncoreFileStatus>> fileStatuses = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<bool> recursive = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId"> (optional)</param>
        /// <param name="sorting"> (optional)</param>
        /// <param name="skipCount"> (optional)</param>
        /// <param name="maxResultCount"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="fileStatuses"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="recursive"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByParentIdPagedApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntriesByParentIdPagedApiResponse> FileManagerFileGetEntriesByParentIdPagedAsync(Option<string> folderId = default, Option<string> sorting = default, Option<int> skipCount = default, Option<int> maxResultCount = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<List<EleoncoreFileStatus>> fileStatuses = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<bool> recursive = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="folderId"> (optional)</param>
        /// <param name="sorting"> (optional)</param>
        /// <param name="skipCount"> (optional)</param>
        /// <param name="maxResultCount"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="fileStatuses"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="recursive"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByParentIdPagedApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntriesByParentIdPagedApiResponse> FileManagerFileGetEntriesByParentIdPagedOrDefaultAsync(Option<string> folderId = default, Option<string> sorting = default, Option<int> skipCount = default, Option<int> maxResultCount = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<List<EleoncoreFileStatus>> fileStatuses = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<bool> recursive = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryByIdApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntryByIdApiResponse> FileManagerFileGetEntryByIdAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryByIdApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntryByIdApiResponse> FileManagerFileGetEntryByIdOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryHistoryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntryHistoryApiResponse> FileManagerFileGetEntryHistoryAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryHistoryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntryHistoryApiResponse> FileManagerFileGetEntryHistoryOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryParentsByIdApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntryParentsByIdApiResponse> FileManagerFileGetEntryParentsByIdAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryParentsByIdApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetEntryParentsByIdApiResponse> FileManagerFileGetEntryParentsByIdOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetFileByTokenApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetFileByTokenApiResponse> FileManagerFileGetFileByTokenAsync(Option<string> id = default, Option<Guid> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetFileByTokenApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetFileByTokenApiResponse> FileManagerFileGetFileByTokenOrDefaultAsync(Option<string> id = default, Option<Guid> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetFileTokenApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetFileTokenApiResponse> FileManagerFileGetFileTokenAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetFileTokenApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetFileTokenApiResponse> FileManagerFileGetFileTokenOrDefaultAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetRootEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetRootEntryApiResponse> FileManagerFileGetRootEntryAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetRootEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileGetRootEntryApiResponse> FileManagerFileGetRootEntryOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerMoveAllEntriesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileMoveAllEntriesApiResponse"/>&gt;</returns>
        Task<IFileManagerFileMoveAllEntriesApiResponse> FileManagerFileMoveAllEntriesAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerMoveAllEntriesDto> fileManagerMoveAllEntriesDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerMoveAllEntriesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileMoveAllEntriesApiResponse"/>&gt;</returns>
        Task<IFileManagerFileMoveAllEntriesApiResponse> FileManagerFileMoveAllEntriesOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerMoveAllEntriesDto> fileManagerMoveAllEntriesDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerMoveEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileMoveEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileMoveEntryApiResponse> FileManagerFileMoveEntryAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerMoveEntryDto> fileManagerMoveEntryDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerMoveEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileMoveEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileMoveEntryApiResponse> FileManagerFileMoveEntryOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerMoveEntryDto> fileManagerMoveEntryDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileReadTextFileApiResponse"/>&gt;</returns>
        Task<IFileManagerFileReadTextFileApiResponse> FileManagerFileReadTextFileAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileReadTextFileApiResponse"/>&gt;</returns>
        Task<IFileManagerFileReadTextFileApiResponse> FileManagerFileReadTextFileOrDefaultAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileReadTextFileByTokenApiResponse"/>&gt;</returns>
        Task<IFileManagerFileReadTextFileByTokenApiResponse> FileManagerFileReadTextFileByTokenAsync(Option<string> id = default, Option<string> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileReadTextFileByTokenApiResponse"/>&gt;</returns>
        Task<IFileManagerFileReadTextFileByTokenApiResponse> FileManagerFileReadTextFileByTokenOrDefaultAsync(Option<string> id = default, Option<string> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerRenameEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileRenameEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileRenameEntryApiResponse> FileManagerFileRenameEntryAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerRenameEntryDto> fileManagerRenameEntryDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerRenameEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileRenameEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileRenameEntryApiResponse> FileManagerFileRenameEntryOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerRenameEntryDto> fileManagerRenameEntryDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileRestoreEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileRestoreEntryApiResponse> FileManagerFileRestoreEntryAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileRestoreEntryApiResponse"/>&gt;</returns>
        Task<IFileManagerFileRestoreEntryApiResponse> FileManagerFileRestoreEntryOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="search"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileSearchEntriesApiResponse"/>&gt;</returns>
        Task<IFileManagerFileSearchEntriesApiResponse> FileManagerFileSearchEntriesAsync(Option<string> search = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="search"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileSearchEntriesApiResponse"/>&gt;</returns>
        Task<IFileManagerFileSearchEntriesApiResponse> FileManagerFileSearchEntriesOrDefaultAsync(Option<string> search = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileManagerFileUploadDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileUploadFilesApiResponse"/>&gt;</returns>
        Task<IFileManagerFileUploadFilesApiResponse> FileManagerFileUploadFilesAsync(Option<FileManagerFileUploadDto> fileManagerFileUploadDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="fileManagerFileUploadDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileUploadFilesApiResponse"/>&gt;</returns>
        Task<IFileManagerFileUploadFilesApiResponse> FileManagerFileUploadFilesOrDefaultAsync(Option<FileManagerFileUploadDto> fileManagerFileUploadDto = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IFileManagerFileCopyEntryApiResponse"/>
    /// </summary>
    public interface IFileManagerFileCopyEntryApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileCreateEntryApiResponse"/>
    /// </summary>
    public interface IFileManagerFileCreateEntryApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<EleonsoftProxy.Model.FileManagerFileSystemEntryDto>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileDeleteEntryApiResponse"/>
    /// </summary>
    public interface IFileManagerFileDeleteEntryApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileDeleteFileTokenApiResponse"/>
    /// </summary>
    public interface IFileManagerFileDeleteFileTokenApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileDownloadAllApiResponse"/>
    /// </summary>
    public interface IFileManagerFileDownloadAllApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<byte[]>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileDownloadFileApiResponse"/>
    /// </summary>
    public interface IFileManagerFileDownloadFileApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<byte[]>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileDownloadFileByTokenApiResponse"/>
    /// </summary>
    public interface IFileManagerFileDownloadFileByTokenApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<byte[]>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileFileViewerApiResponse"/>
    /// </summary>
    public interface IFileManagerFileFileViewerApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<EleonsoftProxy.Model.FileManagerFileSourceDto>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileGetEntriesApiResponse"/>
    /// </summary>
    public interface IFileManagerFileGetEntriesApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<List<FileManagerFileSystemEntryDto>>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileGetEntriesByIdsApiResponse"/>
    /// </summary>
    public interface IFileManagerFileGetEntriesByIdsApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<List<FileManagerFileSystemEntryDto>>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileGetEntriesByParentIdApiResponse"/>
    /// </summary>
    public interface IFileManagerFileGetEntriesByParentIdApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<List<FileManagerFileSystemEntryDto>>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileGetEntriesByParentIdPagedApiResponse"/>
    /// </summary>
    public interface IFileManagerFileGetEntriesByParentIdPagedApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<EleonsoftProxy.Model.EleoncorePagedResultDtoOfFileManagerFileSystemEntryDto>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileGetEntryByIdApiResponse"/>
    /// </summary>
    public interface IFileManagerFileGetEntryByIdApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<EleonsoftProxy.Model.FileManagerFileSystemEntryDto>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileGetEntryHistoryApiResponse"/>
    /// </summary>
    public interface IFileManagerFileGetEntryHistoryApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<List<FileManagerFileSystemEntryDto>>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileGetEntryParentsByIdApiResponse"/>
    /// </summary>
    public interface IFileManagerFileGetEntryParentsByIdApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<List<FileManagerHierarchyFolderDto>>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileGetFileByTokenApiResponse"/>
    /// </summary>
    public interface IFileManagerFileGetFileByTokenApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<byte[]>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileGetFileTokenApiResponse"/>
    /// </summary>
    public interface IFileManagerFileGetFileTokenApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<string>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileGetRootEntryApiResponse"/>
    /// </summary>
    public interface IFileManagerFileGetRootEntryApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<EleonsoftProxy.Model.FileManagerFileSystemEntryDto>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileMoveAllEntriesApiResponse"/>
    /// </summary>
    public interface IFileManagerFileMoveAllEntriesApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileMoveEntryApiResponse"/>
    /// </summary>
    public interface IFileManagerFileMoveEntryApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileReadTextFileApiResponse"/>
    /// </summary>
    public interface IFileManagerFileReadTextFileApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<List<string>>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileReadTextFileByTokenApiResponse"/>
    /// </summary>
    public interface IFileManagerFileReadTextFileByTokenApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<List<string>>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileRenameEntryApiResponse"/>
    /// </summary>
    public interface IFileManagerFileRenameEntryApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<EleonsoftProxy.Model.FileManagerFileSystemEntryDto>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileRestoreEntryApiResponse"/>
    /// </summary>
    public interface IFileManagerFileRestoreEntryApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileSearchEntriesApiResponse"/>
    /// </summary>
    public interface IFileManagerFileSearchEntriesApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<List<FileManagerFileSystemEntryDto>>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IFileManagerFileUploadFilesApiResponse"/>
    /// </summary>
    public interface IFileManagerFileUploadFilesApiResponse : EleonsoftProxy.Client.IApiResponse, IOk<List<FileManagerFileSystemEntryDto>>, IForbidden<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class FileApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileCopyEntry;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileCopyEntry;

        internal void ExecuteOnFileManagerFileCopyEntry(FileApi.FileManagerFileCopyEntryApiResponse apiResponse)
        {
            OnFileManagerFileCopyEntry?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileCopyEntry(Exception exception)
        {
            OnErrorFileManagerFileCopyEntry?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileCreateEntry;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileCreateEntry;

        internal void ExecuteOnFileManagerFileCreateEntry(FileApi.FileManagerFileCreateEntryApiResponse apiResponse)
        {
            OnFileManagerFileCreateEntry?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileCreateEntry(Exception exception)
        {
            OnErrorFileManagerFileCreateEntry?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileDeleteEntry;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileDeleteEntry;

        internal void ExecuteOnFileManagerFileDeleteEntry(FileApi.FileManagerFileDeleteEntryApiResponse apiResponse)
        {
            OnFileManagerFileDeleteEntry?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileDeleteEntry(Exception exception)
        {
            OnErrorFileManagerFileDeleteEntry?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileDeleteFileToken;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileDeleteFileToken;

        internal void ExecuteOnFileManagerFileDeleteFileToken(FileApi.FileManagerFileDeleteFileTokenApiResponse apiResponse)
        {
            OnFileManagerFileDeleteFileToken?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileDeleteFileToken(Exception exception)
        {
            OnErrorFileManagerFileDeleteFileToken?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileDownloadAll;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileDownloadAll;

        internal void ExecuteOnFileManagerFileDownloadAll(FileApi.FileManagerFileDownloadAllApiResponse apiResponse)
        {
            OnFileManagerFileDownloadAll?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileDownloadAll(Exception exception)
        {
            OnErrorFileManagerFileDownloadAll?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileDownloadFile;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileDownloadFile;

        internal void ExecuteOnFileManagerFileDownloadFile(FileApi.FileManagerFileDownloadFileApiResponse apiResponse)
        {
            OnFileManagerFileDownloadFile?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileDownloadFile(Exception exception)
        {
            OnErrorFileManagerFileDownloadFile?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileDownloadFileByToken;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileDownloadFileByToken;

        internal void ExecuteOnFileManagerFileDownloadFileByToken(FileApi.FileManagerFileDownloadFileByTokenApiResponse apiResponse)
        {
            OnFileManagerFileDownloadFileByToken?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileDownloadFileByToken(Exception exception)
        {
            OnErrorFileManagerFileDownloadFileByToken?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileFileViewer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileFileViewer;

        internal void ExecuteOnFileManagerFileFileViewer(FileApi.FileManagerFileFileViewerApiResponse apiResponse)
        {
            OnFileManagerFileFileViewer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileFileViewer(Exception exception)
        {
            OnErrorFileManagerFileFileViewer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileGetEntries;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileGetEntries;

        internal void ExecuteOnFileManagerFileGetEntries(FileApi.FileManagerFileGetEntriesApiResponse apiResponse)
        {
            OnFileManagerFileGetEntries?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileGetEntries(Exception exception)
        {
            OnErrorFileManagerFileGetEntries?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileGetEntriesByIds;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileGetEntriesByIds;

        internal void ExecuteOnFileManagerFileGetEntriesByIds(FileApi.FileManagerFileGetEntriesByIdsApiResponse apiResponse)
        {
            OnFileManagerFileGetEntriesByIds?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileGetEntriesByIds(Exception exception)
        {
            OnErrorFileManagerFileGetEntriesByIds?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileGetEntriesByParentId;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileGetEntriesByParentId;

        internal void ExecuteOnFileManagerFileGetEntriesByParentId(FileApi.FileManagerFileGetEntriesByParentIdApiResponse apiResponse)
        {
            OnFileManagerFileGetEntriesByParentId?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileGetEntriesByParentId(Exception exception)
        {
            OnErrorFileManagerFileGetEntriesByParentId?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileGetEntriesByParentIdPaged;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileGetEntriesByParentIdPaged;

        internal void ExecuteOnFileManagerFileGetEntriesByParentIdPaged(FileApi.FileManagerFileGetEntriesByParentIdPagedApiResponse apiResponse)
        {
            OnFileManagerFileGetEntriesByParentIdPaged?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileGetEntriesByParentIdPaged(Exception exception)
        {
            OnErrorFileManagerFileGetEntriesByParentIdPaged?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileGetEntryById;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileGetEntryById;

        internal void ExecuteOnFileManagerFileGetEntryById(FileApi.FileManagerFileGetEntryByIdApiResponse apiResponse)
        {
            OnFileManagerFileGetEntryById?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileGetEntryById(Exception exception)
        {
            OnErrorFileManagerFileGetEntryById?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileGetEntryHistory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileGetEntryHistory;

        internal void ExecuteOnFileManagerFileGetEntryHistory(FileApi.FileManagerFileGetEntryHistoryApiResponse apiResponse)
        {
            OnFileManagerFileGetEntryHistory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileGetEntryHistory(Exception exception)
        {
            OnErrorFileManagerFileGetEntryHistory?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileGetEntryParentsById;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileGetEntryParentsById;

        internal void ExecuteOnFileManagerFileGetEntryParentsById(FileApi.FileManagerFileGetEntryParentsByIdApiResponse apiResponse)
        {
            OnFileManagerFileGetEntryParentsById?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileGetEntryParentsById(Exception exception)
        {
            OnErrorFileManagerFileGetEntryParentsById?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileGetFileByToken;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileGetFileByToken;

        internal void ExecuteOnFileManagerFileGetFileByToken(FileApi.FileManagerFileGetFileByTokenApiResponse apiResponse)
        {
            OnFileManagerFileGetFileByToken?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileGetFileByToken(Exception exception)
        {
            OnErrorFileManagerFileGetFileByToken?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileGetFileToken;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileGetFileToken;

        internal void ExecuteOnFileManagerFileGetFileToken(FileApi.FileManagerFileGetFileTokenApiResponse apiResponse)
        {
            OnFileManagerFileGetFileToken?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileGetFileToken(Exception exception)
        {
            OnErrorFileManagerFileGetFileToken?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileGetRootEntry;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileGetRootEntry;

        internal void ExecuteOnFileManagerFileGetRootEntry(FileApi.FileManagerFileGetRootEntryApiResponse apiResponse)
        {
            OnFileManagerFileGetRootEntry?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileGetRootEntry(Exception exception)
        {
            OnErrorFileManagerFileGetRootEntry?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileMoveAllEntries;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileMoveAllEntries;

        internal void ExecuteOnFileManagerFileMoveAllEntries(FileApi.FileManagerFileMoveAllEntriesApiResponse apiResponse)
        {
            OnFileManagerFileMoveAllEntries?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileMoveAllEntries(Exception exception)
        {
            OnErrorFileManagerFileMoveAllEntries?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileMoveEntry;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileMoveEntry;

        internal void ExecuteOnFileManagerFileMoveEntry(FileApi.FileManagerFileMoveEntryApiResponse apiResponse)
        {
            OnFileManagerFileMoveEntry?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileMoveEntry(Exception exception)
        {
            OnErrorFileManagerFileMoveEntry?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileReadTextFile;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileReadTextFile;

        internal void ExecuteOnFileManagerFileReadTextFile(FileApi.FileManagerFileReadTextFileApiResponse apiResponse)
        {
            OnFileManagerFileReadTextFile?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileReadTextFile(Exception exception)
        {
            OnErrorFileManagerFileReadTextFile?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileReadTextFileByToken;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileReadTextFileByToken;

        internal void ExecuteOnFileManagerFileReadTextFileByToken(FileApi.FileManagerFileReadTextFileByTokenApiResponse apiResponse)
        {
            OnFileManagerFileReadTextFileByToken?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileReadTextFileByToken(Exception exception)
        {
            OnErrorFileManagerFileReadTextFileByToken?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileRenameEntry;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileRenameEntry;

        internal void ExecuteOnFileManagerFileRenameEntry(FileApi.FileManagerFileRenameEntryApiResponse apiResponse)
        {
            OnFileManagerFileRenameEntry?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileRenameEntry(Exception exception)
        {
            OnErrorFileManagerFileRenameEntry?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileRestoreEntry;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileRestoreEntry;

        internal void ExecuteOnFileManagerFileRestoreEntry(FileApi.FileManagerFileRestoreEntryApiResponse apiResponse)
        {
            OnFileManagerFileRestoreEntry?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileRestoreEntry(Exception exception)
        {
            OnErrorFileManagerFileRestoreEntry?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileSearchEntries;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileSearchEntries;

        internal void ExecuteOnFileManagerFileSearchEntries(FileApi.FileManagerFileSearchEntriesApiResponse apiResponse)
        {
            OnFileManagerFileSearchEntries?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileSearchEntries(Exception exception)
        {
            OnErrorFileManagerFileSearchEntries?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFileManagerFileUploadFiles;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFileManagerFileUploadFiles;

        internal void ExecuteOnFileManagerFileUploadFiles(FileApi.FileManagerFileUploadFilesApiResponse apiResponse)
        {
            OnFileManagerFileUploadFiles?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFileManagerFileUploadFiles(Exception exception)
        {
            OnErrorFileManagerFileUploadFiles?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class FileApi : IFileApi
    {
		public HttpClient HttpClient => SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, GetType().Name);
	
		private readonly EleoncoreSdkConfig _sdkConfig;
        private readonly JsonSerializerOptions _jsonSerializerOptions;
		private readonly ApiConfigurator _apiConfigurator;
		
		private string _accessTokenType;

        private readonly ILoggerFactory LoggerFactory;
        private readonly ILogger<FileApi> Logger;

        /// <summary>
        /// The class containing the events
        /// </summary>
        public FileApiEvents Events { get; }
		
		/// <summary>
        /// Initializes a new instance of the <see cref="FileApi"/> class.
        /// </summary>
        /// <returns></returns>
        public FileApi() : this(ApiConfigurator.GetConfigurator("EleonsoftProxy"))
        {
        }
		
		
        /// <summary>
        /// Initializes a new instance of the <see cref="FileApi"/> class.
        /// </summary>
        /// <returns></returns>
        public FileApi(ApiConfigurator apiConfigurator)
        {
			apiConfigurator.Validate();
		
			_apiConfigurator = apiConfigurator;
            _sdkConfig = apiConfigurator.SdkConfig;
            _jsonSerializerOptions = apiConfigurator.JsonSerializerOptions;
            LoggerFactory = apiConfigurator.LoggerFactory;
            Logger = LoggerFactory.CreateLogger<FileApi>();
            Events = new FileApiEvents();
			
        }
        


        /// <summary>
        /// Switch to use API Authorization dynamically.
        /// </summary>
        public void UseApiAuth()
		{
			if (!_sdkConfig.UseApiAuthorization)
			{
				throw new Exception("API Authorization is not configured in the SDK.");
			}

			_accessTokenType = "api";
		}

        /// <summary>
        /// Switch to use OAuth Authorization dynamically.
        /// </summary>
        public void UseOAuthAuth()
        {
            if (!_sdkConfig.UseOAuthAuthorization)
            {
                throw new Exception("OAuth Authorization is not configured in the SDK.");
            }

            _accessTokenType = "oauth";
        }
		
		public void UseDefaultAuth()
		{
			_accessTokenType = string.Empty;
		}

        public string GetBaseUrl()
		{
			if (_accessTokenType == "api" && _sdkConfig.UseApiAuthorization)
			{
				return _sdkConfig.ApiAuthUrl;
			}

			if ((_accessTokenType == "oauth" || string.IsNullOrEmpty(_accessTokenType)) && _sdkConfig.UseOAuthAuthorization)
			{
				return _sdkConfig.OAuthUrl;
			}
			
			throw new Exception("No valid authorization mode is configured or enabled.");
		}
		
		

        partial void FormatFileManagerFileCopyEntry(ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerCopyEntryDto> fileManagerCopyEntryDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileManagerCopyEntryDto"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileCopyEntry(Option<FileManagerCopyEntryDto> fileManagerCopyEntryDto)
        {
            if (fileManagerCopyEntryDto.IsSet && fileManagerCopyEntryDto.Value == null)
                throw new ArgumentNullException(nameof(fileManagerCopyEntryDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerCopyEntryDto"></param>
        private void AfterFileManagerFileCopyEntryDefaultImplementation(IFileManagerFileCopyEntryApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerCopyEntryDto> fileManagerCopyEntryDto)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileCopyEntry(ref suppressDefaultLog, apiResponseLocalVar, archiveId, type, fileManagerCopyEntryDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerCopyEntryDto"></param>
        partial void AfterFileManagerFileCopyEntry(ref bool suppressDefaultLog, IFileManagerFileCopyEntryApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerCopyEntryDto> fileManagerCopyEntryDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerCopyEntryDto"></param>
        private void OnErrorFileManagerFileCopyEntryDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerCopyEntryDto> fileManagerCopyEntryDto)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileCopyEntry(ref suppressDefaultLog, exception, pathFormat, path, archiveId, type, fileManagerCopyEntryDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerCopyEntryDto"></param>
        partial void OnErrorFileManagerFileCopyEntry(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerCopyEntryDto> fileManagerCopyEntryDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerCopyEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileCopyEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileCopyEntryApiResponse> FileManagerFileCopyEntryOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerCopyEntryDto> fileManagerCopyEntryDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileCopyEntryAsync(archiveId, type, fileManagerCopyEntryDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerCopyEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileCopyEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileCopyEntryApiResponse> FileManagerFileCopyEntryAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerCopyEntryDto> fileManagerCopyEntryDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileCopyEntry(fileManagerCopyEntryDto);

                FormatFileManagerFileCopyEntry(ref archiveId, ref type, fileManagerCopyEntryDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/CopyEntry";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (fileManagerCopyEntryDto.IsSet)
                        httpRequestMessageLocalVar.Content = (fileManagerCopyEntryDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(fileManagerCopyEntryDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileCopyEntryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileCopyEntryApiResponse>();

                        FileManagerFileCopyEntryApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/CopyEntry", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileCopyEntryDefaultImplementation(apiResponseLocalVar, archiveId, type, fileManagerCopyEntryDto);

                        Events.ExecuteOnFileManagerFileCopyEntry(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileCopyEntryDefaultImplementation(e, "/api/file-manager/files/CopyEntry", uriBuilderLocalVar.Path, archiveId, type, fileManagerCopyEntryDto);
                Events.ExecuteOnErrorFileManagerFileCopyEntry(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileCopyEntryApiResponse"/>
        /// </summary>
        public partial class FileManagerFileCopyEntryApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileCopyEntryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileCopyEntryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileCopyEntryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileCopyEntryApiResponse(ILogger<FileManagerFileCopyEntryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileCreateEntry(ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerCreateEntryDto> fileManagerCreateEntryDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileManagerCreateEntryDto"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileCreateEntry(Option<FileManagerCreateEntryDto> fileManagerCreateEntryDto)
        {
            if (fileManagerCreateEntryDto.IsSet && fileManagerCreateEntryDto.Value == null)
                throw new ArgumentNullException(nameof(fileManagerCreateEntryDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerCreateEntryDto"></param>
        private void AfterFileManagerFileCreateEntryDefaultImplementation(IFileManagerFileCreateEntryApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerCreateEntryDto> fileManagerCreateEntryDto)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileCreateEntry(ref suppressDefaultLog, apiResponseLocalVar, archiveId, type, fileManagerCreateEntryDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerCreateEntryDto"></param>
        partial void AfterFileManagerFileCreateEntry(ref bool suppressDefaultLog, IFileManagerFileCreateEntryApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerCreateEntryDto> fileManagerCreateEntryDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerCreateEntryDto"></param>
        private void OnErrorFileManagerFileCreateEntryDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerCreateEntryDto> fileManagerCreateEntryDto)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileCreateEntry(ref suppressDefaultLog, exception, pathFormat, path, archiveId, type, fileManagerCreateEntryDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerCreateEntryDto"></param>
        partial void OnErrorFileManagerFileCreateEntry(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerCreateEntryDto> fileManagerCreateEntryDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerCreateEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileCreateEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileCreateEntryApiResponse> FileManagerFileCreateEntryOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerCreateEntryDto> fileManagerCreateEntryDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileCreateEntryAsync(archiveId, type, fileManagerCreateEntryDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerCreateEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileCreateEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileCreateEntryApiResponse> FileManagerFileCreateEntryAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerCreateEntryDto> fileManagerCreateEntryDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileCreateEntry(fileManagerCreateEntryDto);

                FormatFileManagerFileCreateEntry(ref archiveId, ref type, fileManagerCreateEntryDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/CreateEntry";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (fileManagerCreateEntryDto.IsSet)
                        httpRequestMessageLocalVar.Content = (fileManagerCreateEntryDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(fileManagerCreateEntryDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileCreateEntryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileCreateEntryApiResponse>();

                        FileManagerFileCreateEntryApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/CreateEntry", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileCreateEntryDefaultImplementation(apiResponseLocalVar, archiveId, type, fileManagerCreateEntryDto);

                        Events.ExecuteOnFileManagerFileCreateEntry(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileCreateEntryDefaultImplementation(e, "/api/file-manager/files/CreateEntry", uriBuilderLocalVar.Path, archiveId, type, fileManagerCreateEntryDto);
                Events.ExecuteOnErrorFileManagerFileCreateEntry(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileCreateEntryApiResponse"/>
        /// </summary>
        public partial class FileManagerFileCreateEntryApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileCreateEntryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileCreateEntryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileCreateEntryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileCreateEntryApiResponse(ILogger<FileManagerFileCreateEntryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.FileManagerFileSystemEntryDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.FileManagerFileSystemEntryDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleonsoftProxy.Model.FileManagerFileSystemEntryDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileDeleteEntry(ref Option<string> id, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileDeleteEntry(Option<string> id)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileDeleteEntryDefaultImplementation(IFileManagerFileDeleteEntryApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileDeleteEntry(ref suppressDefaultLog, apiResponseLocalVar, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileDeleteEntry(ref bool suppressDefaultLog, IFileManagerFileDeleteEntryApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileDeleteEntryDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileDeleteEntry(ref suppressDefaultLog, exception, pathFormat, path, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileDeleteEntry(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDeleteEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileDeleteEntryApiResponse> FileManagerFileDeleteEntryOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileDeleteEntryAsync(id, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDeleteEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileDeleteEntryApiResponse> FileManagerFileDeleteEntryAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileDeleteEntry(id);

                FormatFileManagerFileDeleteEntry(ref id, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/DeleteEntry";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileDeleteEntryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileDeleteEntryApiResponse>();

                        FileManagerFileDeleteEntryApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/DeleteEntry", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileDeleteEntryDefaultImplementation(apiResponseLocalVar, id, archiveId, type);

                        Events.ExecuteOnFileManagerFileDeleteEntry(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileDeleteEntryDefaultImplementation(e, "/api/file-manager/files/DeleteEntry", uriBuilderLocalVar.Path, id, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileDeleteEntry(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileDeleteEntryApiResponse"/>
        /// </summary>
        public partial class FileManagerFileDeleteEntryApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileDeleteEntryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileDeleteEntryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileDeleteEntryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileDeleteEntryApiResponse(ILogger<FileManagerFileDeleteEntryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileDeleteFileToken(ref Option<Guid> token, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="token"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileDeleteFileTokenDefaultImplementation(IFileManagerFileDeleteFileTokenApiResponse apiResponseLocalVar, Option<Guid> token, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileDeleteFileToken(ref suppressDefaultLog, apiResponseLocalVar, token, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="token"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileDeleteFileToken(ref bool suppressDefaultLog, IFileManagerFileDeleteFileTokenApiResponse apiResponseLocalVar, Option<Guid> token, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="token"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileDeleteFileTokenDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> token, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileDeleteFileToken(ref suppressDefaultLog, exception, pathFormat, path, token, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="token"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileDeleteFileToken(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> token, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="token"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDeleteFileTokenApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileDeleteFileTokenApiResponse> FileManagerFileDeleteFileTokenOrDefaultAsync(Option<Guid> token = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileDeleteFileTokenAsync(token, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="token"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDeleteFileTokenApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileDeleteFileTokenApiResponse> FileManagerFileDeleteFileTokenAsync(Option<Guid> token = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatFileManagerFileDeleteFileToken(ref token, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/DeleteFileToken";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (token.IsSet)
                        parseQueryStringLocalVar["token"] = ClientUtils.ParameterToString(token.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileDeleteFileTokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileDeleteFileTokenApiResponse>();

                        FileManagerFileDeleteFileTokenApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/DeleteFileToken", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileDeleteFileTokenDefaultImplementation(apiResponseLocalVar, token, archiveId, type);

                        Events.ExecuteOnFileManagerFileDeleteFileToken(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileDeleteFileTokenDefaultImplementation(e, "/api/file-manager/files/DeleteFileToken", uriBuilderLocalVar.Path, token, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileDeleteFileToken(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileDeleteFileTokenApiResponse"/>
        /// </summary>
        public partial class FileManagerFileDeleteFileTokenApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileDeleteFileTokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileDeleteFileTokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileDeleteFileTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileDeleteFileTokenApiResponse(ILogger<FileManagerFileDeleteFileTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileDownloadAll(Option<FileManagerDownloadAllDto> fileManagerDownloadAllDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileManagerDownloadAllDto"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileDownloadAll(Option<FileManagerDownloadAllDto> fileManagerDownloadAllDto)
        {
            if (fileManagerDownloadAllDto.IsSet && fileManagerDownloadAllDto.Value == null)
                throw new ArgumentNullException(nameof(fileManagerDownloadAllDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileManagerDownloadAllDto"></param>
        private void AfterFileManagerFileDownloadAllDefaultImplementation(IFileManagerFileDownloadAllApiResponse apiResponseLocalVar, Option<FileManagerDownloadAllDto> fileManagerDownloadAllDto)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileDownloadAll(ref suppressDefaultLog, apiResponseLocalVar, fileManagerDownloadAllDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileManagerDownloadAllDto"></param>
        partial void AfterFileManagerFileDownloadAll(ref bool suppressDefaultLog, IFileManagerFileDownloadAllApiResponse apiResponseLocalVar, Option<FileManagerDownloadAllDto> fileManagerDownloadAllDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="fileManagerDownloadAllDto"></param>
        private void OnErrorFileManagerFileDownloadAllDefaultImplementation(Exception exception, string pathFormat, string path, Option<FileManagerDownloadAllDto> fileManagerDownloadAllDto)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileDownloadAll(ref suppressDefaultLog, exception, pathFormat, path, fileManagerDownloadAllDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="fileManagerDownloadAllDto"></param>
        partial void OnErrorFileManagerFileDownloadAll(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<FileManagerDownloadAllDto> fileManagerDownloadAllDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="fileManagerDownloadAllDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadAllApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileDownloadAllApiResponse> FileManagerFileDownloadAllOrDefaultAsync(Option<FileManagerDownloadAllDto> fileManagerDownloadAllDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileDownloadAllAsync(fileManagerDownloadAllDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileManagerDownloadAllDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadAllApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileDownloadAllApiResponse> FileManagerFileDownloadAllAsync(Option<FileManagerDownloadAllDto> fileManagerDownloadAllDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileDownloadAll(fileManagerDownloadAllDto);

                FormatFileManagerFileDownloadAll(fileManagerDownloadAllDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/DownloadAll";


                    if (fileManagerDownloadAllDto.IsSet)
                        httpRequestMessageLocalVar.Content = (fileManagerDownloadAllDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(fileManagerDownloadAllDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileDownloadAllApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileDownloadAllApiResponse>();

                        FileManagerFileDownloadAllApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/DownloadAll", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileDownloadAllDefaultImplementation(apiResponseLocalVar, fileManagerDownloadAllDto);

                        Events.ExecuteOnFileManagerFileDownloadAll(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileDownloadAllDefaultImplementation(e, "/api/file-manager/files/DownloadAll", uriBuilderLocalVar.Path, fileManagerDownloadAllDto);
                Events.ExecuteOnErrorFileManagerFileDownloadAll(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileDownloadAllApiResponse"/>
        /// </summary>
        public partial class FileManagerFileDownloadAllApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileDownloadAllApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileDownloadAllApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileDownloadAllApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileDownloadAllApiResponse(ILogger<FileManagerFileDownloadAllApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public byte[] Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<byte[]>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out byte[] result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileDownloadFile(ref Option<string> id, ref Option<bool> isVersion, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileDownloadFile(Option<string> id)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileDownloadFileDefaultImplementation(IFileManagerFileDownloadFileApiResponse apiResponseLocalVar, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileDownloadFile(ref suppressDefaultLog, apiResponseLocalVar, id, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileDownloadFile(ref bool suppressDefaultLog, IFileManagerFileDownloadFileApiResponse apiResponseLocalVar, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileDownloadFileDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileDownloadFile(ref suppressDefaultLog, exception, pathFormat, path, id, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileDownloadFile(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadFileApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileDownloadFileApiResponse> FileManagerFileDownloadFileOrDefaultAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileDownloadFileAsync(id, isVersion, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadFileApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileDownloadFileApiResponse> FileManagerFileDownloadFileAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileDownloadFile(id);

                FormatFileManagerFileDownloadFile(ref id, ref isVersion, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/DownloadFile";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (isVersion.IsSet)
                        parseQueryStringLocalVar["isVersion"] = ClientUtils.ParameterToString(isVersion.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileDownloadFileApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileDownloadFileApiResponse>();

                        FileManagerFileDownloadFileApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/DownloadFile", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileDownloadFileDefaultImplementation(apiResponseLocalVar, id, isVersion, archiveId, type);

                        Events.ExecuteOnFileManagerFileDownloadFile(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileDownloadFileDefaultImplementation(e, "/api/file-manager/files/DownloadFile", uriBuilderLocalVar.Path, id, isVersion, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileDownloadFile(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileDownloadFileApiResponse"/>
        /// </summary>
        public partial class FileManagerFileDownloadFileApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileDownloadFileApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileDownloadFileApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileDownloadFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileDownloadFileApiResponse(ILogger<FileManagerFileDownloadFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public byte[] Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<byte[]>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out byte[] result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileDownloadFileByToken(ref Option<string> id, ref Option<string> token, ref Option<bool> isVersion, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileDownloadFileByToken(Option<string> id, Option<string> token)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));

            if (token.IsSet && token.Value == null)
                throw new ArgumentNullException(nameof(token));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileDownloadFileByTokenDefaultImplementation(IFileManagerFileDownloadFileByTokenApiResponse apiResponseLocalVar, Option<string> id, Option<string> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileDownloadFileByToken(ref suppressDefaultLog, apiResponseLocalVar, id, token, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileDownloadFileByToken(ref bool suppressDefaultLog, IFileManagerFileDownloadFileByTokenApiResponse apiResponseLocalVar, Option<string> id, Option<string> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileDownloadFileByTokenDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<string> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileDownloadFileByToken(ref suppressDefaultLog, exception, pathFormat, path, id, token, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileDownloadFileByToken(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<string> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadFileByTokenApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileDownloadFileByTokenApiResponse> FileManagerFileDownloadFileByTokenOrDefaultAsync(Option<string> id = default, Option<string> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileDownloadFileByTokenAsync(id, token, isVersion, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileDownloadFileByTokenApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileDownloadFileByTokenApiResponse> FileManagerFileDownloadFileByTokenAsync(Option<string> id = default, Option<string> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileDownloadFileByToken(id, token);

                FormatFileManagerFileDownloadFileByToken(ref id, ref token, ref isVersion, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/DownloadFileByToken";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (token.IsSet)
                        parseQueryStringLocalVar["token"] = ClientUtils.ParameterToString(token.Value);

                    if (isVersion.IsSet)
                        parseQueryStringLocalVar["isVersion"] = ClientUtils.ParameterToString(isVersion.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileDownloadFileByTokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileDownloadFileByTokenApiResponse>();

                        FileManagerFileDownloadFileByTokenApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/DownloadFileByToken", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileDownloadFileByTokenDefaultImplementation(apiResponseLocalVar, id, token, isVersion, archiveId, type);

                        Events.ExecuteOnFileManagerFileDownloadFileByToken(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileDownloadFileByTokenDefaultImplementation(e, "/api/file-manager/files/DownloadFileByToken", uriBuilderLocalVar.Path, id, token, isVersion, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileDownloadFileByToken(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileDownloadFileByTokenApiResponse"/>
        /// </summary>
        public partial class FileManagerFileDownloadFileByTokenApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileDownloadFileByTokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileDownloadFileByTokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileDownloadFileByTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileDownloadFileByTokenApiResponse(ILogger<FileManagerFileDownloadFileByTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public byte[] Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<byte[]>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out byte[] result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileFileViewer(ref Option<string> id, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileFileViewer(Option<string> id)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileFileViewerDefaultImplementation(IFileManagerFileFileViewerApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileFileViewer(ref suppressDefaultLog, apiResponseLocalVar, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileFileViewer(ref bool suppressDefaultLog, IFileManagerFileFileViewerApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileFileViewerDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileFileViewer(ref suppressDefaultLog, exception, pathFormat, path, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileFileViewer(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileFileViewerApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileFileViewerApiResponse> FileManagerFileFileViewerOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileFileViewerAsync(id, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileFileViewerApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileFileViewerApiResponse> FileManagerFileFileViewerAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileFileViewer(id);

                FormatFileManagerFileFileViewer(ref id, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/FileViewer";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileFileViewerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileFileViewerApiResponse>();

                        FileManagerFileFileViewerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/FileViewer", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileFileViewerDefaultImplementation(apiResponseLocalVar, id, archiveId, type);

                        Events.ExecuteOnFileManagerFileFileViewer(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileFileViewerDefaultImplementation(e, "/api/file-manager/files/FileViewer", uriBuilderLocalVar.Path, id, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileFileViewer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileFileViewerApiResponse"/>
        /// </summary>
        public partial class FileManagerFileFileViewerApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileFileViewerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileFileViewerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileFileViewerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileFileViewerApiResponse(ILogger<FileManagerFileFileViewerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.FileManagerFileSourceDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.FileManagerFileSourceDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleonsoftProxy.Model.FileManagerFileSourceDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileGetEntries(Option<FileManagerEntryFilterDto> fileManagerEntryFilterDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileManagerEntryFilterDto"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileGetEntries(Option<FileManagerEntryFilterDto> fileManagerEntryFilterDto)
        {
            if (fileManagerEntryFilterDto.IsSet && fileManagerEntryFilterDto.Value == null)
                throw new ArgumentNullException(nameof(fileManagerEntryFilterDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileManagerEntryFilterDto"></param>
        private void AfterFileManagerFileGetEntriesDefaultImplementation(IFileManagerFileGetEntriesApiResponse apiResponseLocalVar, Option<FileManagerEntryFilterDto> fileManagerEntryFilterDto)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileGetEntries(ref suppressDefaultLog, apiResponseLocalVar, fileManagerEntryFilterDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileManagerEntryFilterDto"></param>
        partial void AfterFileManagerFileGetEntries(ref bool suppressDefaultLog, IFileManagerFileGetEntriesApiResponse apiResponseLocalVar, Option<FileManagerEntryFilterDto> fileManagerEntryFilterDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="fileManagerEntryFilterDto"></param>
        private void OnErrorFileManagerFileGetEntriesDefaultImplementation(Exception exception, string pathFormat, string path, Option<FileManagerEntryFilterDto> fileManagerEntryFilterDto)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileGetEntries(ref suppressDefaultLog, exception, pathFormat, path, fileManagerEntryFilterDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="fileManagerEntryFilterDto"></param>
        partial void OnErrorFileManagerFileGetEntries(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<FileManagerEntryFilterDto> fileManagerEntryFilterDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="fileManagerEntryFilterDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntriesApiResponse> FileManagerFileGetEntriesOrDefaultAsync(Option<FileManagerEntryFilterDto> fileManagerEntryFilterDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileGetEntriesAsync(fileManagerEntryFilterDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileManagerEntryFilterDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntriesApiResponse> FileManagerFileGetEntriesAsync(Option<FileManagerEntryFilterDto> fileManagerEntryFilterDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileGetEntries(fileManagerEntryFilterDto);

                FormatFileManagerFileGetEntries(fileManagerEntryFilterDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/GetEntries";


                    if (fileManagerEntryFilterDto.IsSet)
                        httpRequestMessageLocalVar.Content = (fileManagerEntryFilterDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(fileManagerEntryFilterDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileGetEntriesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileGetEntriesApiResponse>();

                        FileManagerFileGetEntriesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/GetEntries", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileGetEntriesDefaultImplementation(apiResponseLocalVar, fileManagerEntryFilterDto);

                        Events.ExecuteOnFileManagerFileGetEntries(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileGetEntriesDefaultImplementation(e, "/api/file-manager/files/GetEntries", uriBuilderLocalVar.Path, fileManagerEntryFilterDto);
                Events.ExecuteOnErrorFileManagerFileGetEntries(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileGetEntriesApiResponse"/>
        /// </summary>
        public partial class FileManagerFileGetEntriesApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileGetEntriesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileGetEntriesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileGetEntriesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileGetEntriesApiResponse(ILogger<FileManagerFileGetEntriesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<FileManagerFileSystemEntryDto> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<FileManagerFileSystemEntryDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<FileManagerFileSystemEntryDto> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileGetEntriesByIds(ref Option<Guid> archiveId, ref Option<FileManagerEntryKind> kind, ref Option<EleonsoftModuleCollectorFileManagerType> type, Option<List<string>> requestBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="requestBody"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileGetEntriesByIds(Option<List<string>> requestBody)
        {
            if (requestBody.IsSet && requestBody.Value == null)
                throw new ArgumentNullException(nameof(requestBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="type"></param>
        /// <param name="requestBody"></param>
        private void AfterFileManagerFileGetEntriesByIdsDefaultImplementation(IFileManagerFileGetEntriesByIdsApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<EleonsoftModuleCollectorFileManagerType> type, Option<List<string>> requestBody)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileGetEntriesByIds(ref suppressDefaultLog, apiResponseLocalVar, archiveId, kind, type, requestBody);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="type"></param>
        /// <param name="requestBody"></param>
        partial void AfterFileManagerFileGetEntriesByIds(ref bool suppressDefaultLog, IFileManagerFileGetEntriesByIdsApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<EleonsoftModuleCollectorFileManagerType> type, Option<List<string>> requestBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="type"></param>
        /// <param name="requestBody"></param>
        private void OnErrorFileManagerFileGetEntriesByIdsDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<EleonsoftModuleCollectorFileManagerType> type, Option<List<string>> requestBody)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileGetEntriesByIds(ref suppressDefaultLog, exception, pathFormat, path, archiveId, kind, type, requestBody);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="type"></param>
        /// <param name="requestBody"></param>
        partial void OnErrorFileManagerFileGetEntriesByIds(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<EleonsoftModuleCollectorFileManagerType> type, Option<List<string>> requestBody);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="requestBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByIdsApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntriesByIdsApiResponse> FileManagerFileGetEntriesByIdsOrDefaultAsync(Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<List<string>> requestBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileGetEntriesByIdsAsync(archiveId, kind, type, requestBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="requestBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByIdsApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntriesByIdsApiResponse> FileManagerFileGetEntriesByIdsAsync(Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<List<string>> requestBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileGetEntriesByIds(requestBody);

                FormatFileManagerFileGetEntriesByIds(ref archiveId, ref kind, ref type, requestBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/GetEntriesByIds";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (kind.IsSet)
                        parseQueryStringLocalVar["kind"] = ClientUtils.ParameterToString(kind.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (requestBody.IsSet)
                        httpRequestMessageLocalVar.Content = (requestBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(requestBody.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileGetEntriesByIdsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileGetEntriesByIdsApiResponse>();

                        FileManagerFileGetEntriesByIdsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/GetEntriesByIds", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileGetEntriesByIdsDefaultImplementation(apiResponseLocalVar, archiveId, kind, type, requestBody);

                        Events.ExecuteOnFileManagerFileGetEntriesByIds(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileGetEntriesByIdsDefaultImplementation(e, "/api/file-manager/files/GetEntriesByIds", uriBuilderLocalVar.Path, archiveId, kind, type, requestBody);
                Events.ExecuteOnErrorFileManagerFileGetEntriesByIds(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileGetEntriesByIdsApiResponse"/>
        /// </summary>
        public partial class FileManagerFileGetEntriesByIdsApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileGetEntriesByIdsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileGetEntriesByIdsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileGetEntriesByIdsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileGetEntriesByIdsApiResponse(ILogger<FileManagerFileGetEntriesByIdsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<FileManagerFileSystemEntryDto> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<FileManagerFileSystemEntryDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<FileManagerFileSystemEntryDto> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileGetEntriesByParentId(ref Option<string> parentId, ref Option<Guid> archiveId, ref Option<FileManagerEntryKind> kind, Option<List<EleoncoreFileStatus>> fileStatuses, ref Option<EleonsoftModuleCollectorFileManagerType> type, ref Option<bool> recursive);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="parentId"></param>
        /// <param name="fileStatuses"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileGetEntriesByParentId(Option<string> parentId, Option<List<EleoncoreFileStatus>> fileStatuses)
        {
            if (parentId.IsSet && parentId.Value == null)
                throw new ArgumentNullException(nameof(parentId));

            if (fileStatuses.IsSet && fileStatuses.Value == null)
                throw new ArgumentNullException(nameof(fileStatuses));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="parentId"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="fileStatuses"></param>
        /// <param name="type"></param>
        /// <param name="recursive"></param>
        private void AfterFileManagerFileGetEntriesByParentIdDefaultImplementation(IFileManagerFileGetEntriesByParentIdApiResponse apiResponseLocalVar, Option<string> parentId, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<List<EleoncoreFileStatus>> fileStatuses, Option<EleonsoftModuleCollectorFileManagerType> type, Option<bool> recursive)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileGetEntriesByParentId(ref suppressDefaultLog, apiResponseLocalVar, parentId, archiveId, kind, fileStatuses, type, recursive);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="parentId"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="fileStatuses"></param>
        /// <param name="type"></param>
        /// <param name="recursive"></param>
        partial void AfterFileManagerFileGetEntriesByParentId(ref bool suppressDefaultLog, IFileManagerFileGetEntriesByParentIdApiResponse apiResponseLocalVar, Option<string> parentId, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<List<EleoncoreFileStatus>> fileStatuses, Option<EleonsoftModuleCollectorFileManagerType> type, Option<bool> recursive);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="parentId"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="fileStatuses"></param>
        /// <param name="type"></param>
        /// <param name="recursive"></param>
        private void OnErrorFileManagerFileGetEntriesByParentIdDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> parentId, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<List<EleoncoreFileStatus>> fileStatuses, Option<EleonsoftModuleCollectorFileManagerType> type, Option<bool> recursive)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileGetEntriesByParentId(ref suppressDefaultLog, exception, pathFormat, path, parentId, archiveId, kind, fileStatuses, type, recursive);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="parentId"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="fileStatuses"></param>
        /// <param name="type"></param>
        /// <param name="recursive"></param>
        partial void OnErrorFileManagerFileGetEntriesByParentId(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> parentId, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<List<EleoncoreFileStatus>> fileStatuses, Option<EleonsoftModuleCollectorFileManagerType> type, Option<bool> recursive);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="parentId"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="fileStatuses"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="recursive"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByParentIdApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntriesByParentIdApiResponse> FileManagerFileGetEntriesByParentIdOrDefaultAsync(Option<string> parentId = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<List<EleoncoreFileStatus>> fileStatuses = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<bool> recursive = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileGetEntriesByParentIdAsync(parentId, archiveId, kind, fileStatuses, type, recursive, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="parentId"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="fileStatuses"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="recursive"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByParentIdApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntriesByParentIdApiResponse> FileManagerFileGetEntriesByParentIdAsync(Option<string> parentId = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<List<EleoncoreFileStatus>> fileStatuses = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<bool> recursive = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileGetEntriesByParentId(parentId, fileStatuses);

                FormatFileManagerFileGetEntriesByParentId(ref parentId, ref archiveId, ref kind, fileStatuses, ref type, ref recursive);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/GetEntriesByParentId";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (parentId.IsSet)
                        parseQueryStringLocalVar["parentId"] = ClientUtils.ParameterToString(parentId.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (kind.IsSet)
                        parseQueryStringLocalVar["kind"] = ClientUtils.ParameterToString(kind.Value);

                    if (fileStatuses.IsSet)
                        parseQueryStringLocalVar["fileStatuses"] = ClientUtils.ParameterToString(fileStatuses.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    if (recursive.IsSet)
                        parseQueryStringLocalVar["recursive"] = ClientUtils.ParameterToString(recursive.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileGetEntriesByParentIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileGetEntriesByParentIdApiResponse>();

                        FileManagerFileGetEntriesByParentIdApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/GetEntriesByParentId", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileGetEntriesByParentIdDefaultImplementation(apiResponseLocalVar, parentId, archiveId, kind, fileStatuses, type, recursive);

                        Events.ExecuteOnFileManagerFileGetEntriesByParentId(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileGetEntriesByParentIdDefaultImplementation(e, "/api/file-manager/files/GetEntriesByParentId", uriBuilderLocalVar.Path, parentId, archiveId, kind, fileStatuses, type, recursive);
                Events.ExecuteOnErrorFileManagerFileGetEntriesByParentId(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileGetEntriesByParentIdApiResponse"/>
        /// </summary>
        public partial class FileManagerFileGetEntriesByParentIdApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileGetEntriesByParentIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileGetEntriesByParentIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileGetEntriesByParentIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileGetEntriesByParentIdApiResponse(ILogger<FileManagerFileGetEntriesByParentIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<FileManagerFileSystemEntryDto> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<FileManagerFileSystemEntryDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<FileManagerFileSystemEntryDto> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileGetEntriesByParentIdPaged(ref Option<string> folderId, ref Option<string> sorting, ref Option<int> skipCount, ref Option<int> maxResultCount, ref Option<Guid> archiveId, ref Option<FileManagerEntryKind> kind, Option<List<EleoncoreFileStatus>> fileStatuses, ref Option<EleonsoftModuleCollectorFileManagerType> type, ref Option<bool> recursive);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="folderId"></param>
        /// <param name="sorting"></param>
        /// <param name="fileStatuses"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileGetEntriesByParentIdPaged(Option<string> folderId, Option<string> sorting, Option<List<EleoncoreFileStatus>> fileStatuses)
        {
            if (folderId.IsSet && folderId.Value == null)
                throw new ArgumentNullException(nameof(folderId));

            if (sorting.IsSet && sorting.Value == null)
                throw new ArgumentNullException(nameof(sorting));

            if (fileStatuses.IsSet && fileStatuses.Value == null)
                throw new ArgumentNullException(nameof(fileStatuses));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        /// <param name="sorting"></param>
        /// <param name="skipCount"></param>
        /// <param name="maxResultCount"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="fileStatuses"></param>
        /// <param name="type"></param>
        /// <param name="recursive"></param>
        private void AfterFileManagerFileGetEntriesByParentIdPagedDefaultImplementation(IFileManagerFileGetEntriesByParentIdPagedApiResponse apiResponseLocalVar, Option<string> folderId, Option<string> sorting, Option<int> skipCount, Option<int> maxResultCount, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<List<EleoncoreFileStatus>> fileStatuses, Option<EleonsoftModuleCollectorFileManagerType> type, Option<bool> recursive)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileGetEntriesByParentIdPaged(ref suppressDefaultLog, apiResponseLocalVar, folderId, sorting, skipCount, maxResultCount, archiveId, kind, fileStatuses, type, recursive);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        /// <param name="sorting"></param>
        /// <param name="skipCount"></param>
        /// <param name="maxResultCount"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="fileStatuses"></param>
        /// <param name="type"></param>
        /// <param name="recursive"></param>
        partial void AfterFileManagerFileGetEntriesByParentIdPaged(ref bool suppressDefaultLog, IFileManagerFileGetEntriesByParentIdPagedApiResponse apiResponseLocalVar, Option<string> folderId, Option<string> sorting, Option<int> skipCount, Option<int> maxResultCount, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<List<EleoncoreFileStatus>> fileStatuses, Option<EleonsoftModuleCollectorFileManagerType> type, Option<bool> recursive);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        /// <param name="sorting"></param>
        /// <param name="skipCount"></param>
        /// <param name="maxResultCount"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="fileStatuses"></param>
        /// <param name="type"></param>
        /// <param name="recursive"></param>
        private void OnErrorFileManagerFileGetEntriesByParentIdPagedDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> folderId, Option<string> sorting, Option<int> skipCount, Option<int> maxResultCount, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<List<EleoncoreFileStatus>> fileStatuses, Option<EleonsoftModuleCollectorFileManagerType> type, Option<bool> recursive)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileGetEntriesByParentIdPaged(ref suppressDefaultLog, exception, pathFormat, path, folderId, sorting, skipCount, maxResultCount, archiveId, kind, fileStatuses, type, recursive);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        /// <param name="sorting"></param>
        /// <param name="skipCount"></param>
        /// <param name="maxResultCount"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="fileStatuses"></param>
        /// <param name="type"></param>
        /// <param name="recursive"></param>
        partial void OnErrorFileManagerFileGetEntriesByParentIdPaged(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> folderId, Option<string> sorting, Option<int> skipCount, Option<int> maxResultCount, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<List<EleoncoreFileStatus>> fileStatuses, Option<EleonsoftModuleCollectorFileManagerType> type, Option<bool> recursive);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="folderId"> (optional)</param>
        /// <param name="sorting"> (optional)</param>
        /// <param name="skipCount"> (optional)</param>
        /// <param name="maxResultCount"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="fileStatuses"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="recursive"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByParentIdPagedApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntriesByParentIdPagedApiResponse> FileManagerFileGetEntriesByParentIdPagedOrDefaultAsync(Option<string> folderId = default, Option<string> sorting = default, Option<int> skipCount = default, Option<int> maxResultCount = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<List<EleoncoreFileStatus>> fileStatuses = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<bool> recursive = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileGetEntriesByParentIdPagedAsync(folderId, sorting, skipCount, maxResultCount, archiveId, kind, fileStatuses, type, recursive, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId"> (optional)</param>
        /// <param name="sorting"> (optional)</param>
        /// <param name="skipCount"> (optional)</param>
        /// <param name="maxResultCount"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="fileStatuses"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="recursive"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntriesByParentIdPagedApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntriesByParentIdPagedApiResponse> FileManagerFileGetEntriesByParentIdPagedAsync(Option<string> folderId = default, Option<string> sorting = default, Option<int> skipCount = default, Option<int> maxResultCount = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<List<EleoncoreFileStatus>> fileStatuses = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<bool> recursive = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileGetEntriesByParentIdPaged(folderId, sorting, fileStatuses);

                FormatFileManagerFileGetEntriesByParentIdPaged(ref folderId, ref sorting, ref skipCount, ref maxResultCount, ref archiveId, ref kind, fileStatuses, ref type, ref recursive);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/GetEntriesByParentIdPaged";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (folderId.IsSet)
                        parseQueryStringLocalVar["folderId"] = ClientUtils.ParameterToString(folderId.Value);

                    if (sorting.IsSet)
                        parseQueryStringLocalVar["sorting"] = ClientUtils.ParameterToString(sorting.Value);

                    if (skipCount.IsSet)
                        parseQueryStringLocalVar["skipCount"] = ClientUtils.ParameterToString(skipCount.Value);

                    if (maxResultCount.IsSet)
                        parseQueryStringLocalVar["maxResultCount"] = ClientUtils.ParameterToString(maxResultCount.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (kind.IsSet)
                        parseQueryStringLocalVar["kind"] = ClientUtils.ParameterToString(kind.Value);

                    if (fileStatuses.IsSet)
                        parseQueryStringLocalVar["fileStatuses"] = ClientUtils.ParameterToString(fileStatuses.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    if (recursive.IsSet)
                        parseQueryStringLocalVar["recursive"] = ClientUtils.ParameterToString(recursive.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileGetEntriesByParentIdPagedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileGetEntriesByParentIdPagedApiResponse>();

                        FileManagerFileGetEntriesByParentIdPagedApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/GetEntriesByParentIdPaged", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileGetEntriesByParentIdPagedDefaultImplementation(apiResponseLocalVar, folderId, sorting, skipCount, maxResultCount, archiveId, kind, fileStatuses, type, recursive);

                        Events.ExecuteOnFileManagerFileGetEntriesByParentIdPaged(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileGetEntriesByParentIdPagedDefaultImplementation(e, "/api/file-manager/files/GetEntriesByParentIdPaged", uriBuilderLocalVar.Path, folderId, sorting, skipCount, maxResultCount, archiveId, kind, fileStatuses, type, recursive);
                Events.ExecuteOnErrorFileManagerFileGetEntriesByParentIdPaged(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileGetEntriesByParentIdPagedApiResponse"/>
        /// </summary>
        public partial class FileManagerFileGetEntriesByParentIdPagedApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileGetEntriesByParentIdPagedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileGetEntriesByParentIdPagedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileGetEntriesByParentIdPagedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileGetEntriesByParentIdPagedApiResponse(ILogger<FileManagerFileGetEntriesByParentIdPagedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncorePagedResultDtoOfFileManagerFileSystemEntryDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncorePagedResultDtoOfFileManagerFileSystemEntryDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncorePagedResultDtoOfFileManagerFileSystemEntryDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileGetEntryById(ref Option<string> id, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileGetEntryById(Option<string> id)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileGetEntryByIdDefaultImplementation(IFileManagerFileGetEntryByIdApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileGetEntryById(ref suppressDefaultLog, apiResponseLocalVar, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileGetEntryById(ref bool suppressDefaultLog, IFileManagerFileGetEntryByIdApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileGetEntryByIdDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileGetEntryById(ref suppressDefaultLog, exception, pathFormat, path, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileGetEntryById(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryByIdApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntryByIdApiResponse> FileManagerFileGetEntryByIdOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileGetEntryByIdAsync(id, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryByIdApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntryByIdApiResponse> FileManagerFileGetEntryByIdAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileGetEntryById(id);

                FormatFileManagerFileGetEntryById(ref id, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/GetEntryById";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileGetEntryByIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileGetEntryByIdApiResponse>();

                        FileManagerFileGetEntryByIdApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/GetEntryById", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileGetEntryByIdDefaultImplementation(apiResponseLocalVar, id, archiveId, type);

                        Events.ExecuteOnFileManagerFileGetEntryById(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileGetEntryByIdDefaultImplementation(e, "/api/file-manager/files/GetEntryById", uriBuilderLocalVar.Path, id, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileGetEntryById(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileGetEntryByIdApiResponse"/>
        /// </summary>
        public partial class FileManagerFileGetEntryByIdApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileGetEntryByIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileGetEntryByIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileGetEntryByIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileGetEntryByIdApiResponse(ILogger<FileManagerFileGetEntryByIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.FileManagerFileSystemEntryDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.FileManagerFileSystemEntryDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleonsoftProxy.Model.FileManagerFileSystemEntryDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileGetEntryHistory(ref Option<string> id, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileGetEntryHistory(Option<string> id)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileGetEntryHistoryDefaultImplementation(IFileManagerFileGetEntryHistoryApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileGetEntryHistory(ref suppressDefaultLog, apiResponseLocalVar, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileGetEntryHistory(ref bool suppressDefaultLog, IFileManagerFileGetEntryHistoryApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileGetEntryHistoryDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileGetEntryHistory(ref suppressDefaultLog, exception, pathFormat, path, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileGetEntryHistory(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryHistoryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntryHistoryApiResponse> FileManagerFileGetEntryHistoryOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileGetEntryHistoryAsync(id, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryHistoryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntryHistoryApiResponse> FileManagerFileGetEntryHistoryAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileGetEntryHistory(id);

                FormatFileManagerFileGetEntryHistory(ref id, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/GetEntryHistory";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileGetEntryHistoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileGetEntryHistoryApiResponse>();

                        FileManagerFileGetEntryHistoryApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/GetEntryHistory", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileGetEntryHistoryDefaultImplementation(apiResponseLocalVar, id, archiveId, type);

                        Events.ExecuteOnFileManagerFileGetEntryHistory(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileGetEntryHistoryDefaultImplementation(e, "/api/file-manager/files/GetEntryHistory", uriBuilderLocalVar.Path, id, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileGetEntryHistory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileGetEntryHistoryApiResponse"/>
        /// </summary>
        public partial class FileManagerFileGetEntryHistoryApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileGetEntryHistoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileGetEntryHistoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileGetEntryHistoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileGetEntryHistoryApiResponse(ILogger<FileManagerFileGetEntryHistoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<FileManagerFileSystemEntryDto> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<FileManagerFileSystemEntryDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<FileManagerFileSystemEntryDto> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileGetEntryParentsById(ref Option<string> id, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileGetEntryParentsById(Option<string> id)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileGetEntryParentsByIdDefaultImplementation(IFileManagerFileGetEntryParentsByIdApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileGetEntryParentsById(ref suppressDefaultLog, apiResponseLocalVar, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileGetEntryParentsById(ref bool suppressDefaultLog, IFileManagerFileGetEntryParentsByIdApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileGetEntryParentsByIdDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileGetEntryParentsById(ref suppressDefaultLog, exception, pathFormat, path, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileGetEntryParentsById(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryParentsByIdApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntryParentsByIdApiResponse> FileManagerFileGetEntryParentsByIdOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileGetEntryParentsByIdAsync(id, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetEntryParentsByIdApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetEntryParentsByIdApiResponse> FileManagerFileGetEntryParentsByIdAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileGetEntryParentsById(id);

                FormatFileManagerFileGetEntryParentsById(ref id, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/GetEntryParentsById";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileGetEntryParentsByIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileGetEntryParentsByIdApiResponse>();

                        FileManagerFileGetEntryParentsByIdApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/GetEntryParentsById", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileGetEntryParentsByIdDefaultImplementation(apiResponseLocalVar, id, archiveId, type);

                        Events.ExecuteOnFileManagerFileGetEntryParentsById(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileGetEntryParentsByIdDefaultImplementation(e, "/api/file-manager/files/GetEntryParentsById", uriBuilderLocalVar.Path, id, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileGetEntryParentsById(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileGetEntryParentsByIdApiResponse"/>
        /// </summary>
        public partial class FileManagerFileGetEntryParentsByIdApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileGetEntryParentsByIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileGetEntryParentsByIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileGetEntryParentsByIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileGetEntryParentsByIdApiResponse(ILogger<FileManagerFileGetEntryParentsByIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<FileManagerHierarchyFolderDto> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<FileManagerHierarchyFolderDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<FileManagerHierarchyFolderDto> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileGetFileByToken(ref Option<string> id, ref Option<Guid> token, ref Option<bool> isVersion, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileGetFileByToken(Option<string> id)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileGetFileByTokenDefaultImplementation(IFileManagerFileGetFileByTokenApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileGetFileByToken(ref suppressDefaultLog, apiResponseLocalVar, id, token, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileGetFileByToken(ref bool suppressDefaultLog, IFileManagerFileGetFileByTokenApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileGetFileByTokenDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileGetFileByToken(ref suppressDefaultLog, exception, pathFormat, path, id, token, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileGetFileByToken(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetFileByTokenApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetFileByTokenApiResponse> FileManagerFileGetFileByTokenOrDefaultAsync(Option<string> id = default, Option<Guid> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileGetFileByTokenAsync(id, token, isVersion, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetFileByTokenApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetFileByTokenApiResponse> FileManagerFileGetFileByTokenAsync(Option<string> id = default, Option<Guid> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileGetFileByToken(id);

                FormatFileManagerFileGetFileByToken(ref id, ref token, ref isVersion, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/GetFileByToken";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (token.IsSet)
                        parseQueryStringLocalVar["token"] = ClientUtils.ParameterToString(token.Value);

                    if (isVersion.IsSet)
                        parseQueryStringLocalVar["isVersion"] = ClientUtils.ParameterToString(isVersion.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileGetFileByTokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileGetFileByTokenApiResponse>();

                        FileManagerFileGetFileByTokenApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/GetFileByToken", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileGetFileByTokenDefaultImplementation(apiResponseLocalVar, id, token, isVersion, archiveId, type);

                        Events.ExecuteOnFileManagerFileGetFileByToken(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileGetFileByTokenDefaultImplementation(e, "/api/file-manager/files/GetFileByToken", uriBuilderLocalVar.Path, id, token, isVersion, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileGetFileByToken(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileGetFileByTokenApiResponse"/>
        /// </summary>
        public partial class FileManagerFileGetFileByTokenApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileGetFileByTokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileGetFileByTokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileGetFileByTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileGetFileByTokenApiResponse(ILogger<FileManagerFileGetFileByTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public byte[] Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<byte[]>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out byte[] result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileGetFileToken(ref Option<string> id, ref Option<bool> isVersion, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileGetFileToken(Option<string> id)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileGetFileTokenDefaultImplementation(IFileManagerFileGetFileTokenApiResponse apiResponseLocalVar, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileGetFileToken(ref suppressDefaultLog, apiResponseLocalVar, id, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileGetFileToken(ref bool suppressDefaultLog, IFileManagerFileGetFileTokenApiResponse apiResponseLocalVar, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileGetFileTokenDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileGetFileToken(ref suppressDefaultLog, exception, pathFormat, path, id, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileGetFileToken(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetFileTokenApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetFileTokenApiResponse> FileManagerFileGetFileTokenOrDefaultAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileGetFileTokenAsync(id, isVersion, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetFileTokenApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetFileTokenApiResponse> FileManagerFileGetFileTokenAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileGetFileToken(id);

                FormatFileManagerFileGetFileToken(ref id, ref isVersion, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/GetFileToken";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (isVersion.IsSet)
                        parseQueryStringLocalVar["isVersion"] = ClientUtils.ParameterToString(isVersion.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileGetFileTokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileGetFileTokenApiResponse>();

                        FileManagerFileGetFileTokenApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/GetFileToken", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileGetFileTokenDefaultImplementation(apiResponseLocalVar, id, isVersion, archiveId, type);

                        Events.ExecuteOnFileManagerFileGetFileToken(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileGetFileTokenDefaultImplementation(e, "/api/file-manager/files/GetFileToken", uriBuilderLocalVar.Path, id, isVersion, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileGetFileToken(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileGetFileTokenApiResponse"/>
        /// </summary>
        public partial class FileManagerFileGetFileTokenApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileGetFileTokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileGetFileTokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileGetFileTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileGetFileTokenApiResponse(ILogger<FileManagerFileGetFileTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public string Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<string>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out string result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileGetRootEntry(ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileGetRootEntryDefaultImplementation(IFileManagerFileGetRootEntryApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileGetRootEntry(ref suppressDefaultLog, apiResponseLocalVar, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileGetRootEntry(ref bool suppressDefaultLog, IFileManagerFileGetRootEntryApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileGetRootEntryDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileGetRootEntry(ref suppressDefaultLog, exception, pathFormat, path, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileGetRootEntry(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetRootEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetRootEntryApiResponse> FileManagerFileGetRootEntryOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileGetRootEntryAsync(archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileGetRootEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileGetRootEntryApiResponse> FileManagerFileGetRootEntryAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatFileManagerFileGetRootEntry(ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/GetRootEntry";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileGetRootEntryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileGetRootEntryApiResponse>();

                        FileManagerFileGetRootEntryApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/GetRootEntry", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileGetRootEntryDefaultImplementation(apiResponseLocalVar, archiveId, type);

                        Events.ExecuteOnFileManagerFileGetRootEntry(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileGetRootEntryDefaultImplementation(e, "/api/file-manager/files/GetRootEntry", uriBuilderLocalVar.Path, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileGetRootEntry(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileGetRootEntryApiResponse"/>
        /// </summary>
        public partial class FileManagerFileGetRootEntryApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileGetRootEntryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileGetRootEntryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileGetRootEntryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileGetRootEntryApiResponse(ILogger<FileManagerFileGetRootEntryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.FileManagerFileSystemEntryDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.FileManagerFileSystemEntryDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleonsoftProxy.Model.FileManagerFileSystemEntryDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileMoveAllEntries(ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerMoveAllEntriesDto> fileManagerMoveAllEntriesDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileManagerMoveAllEntriesDto"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileMoveAllEntries(Option<FileManagerMoveAllEntriesDto> fileManagerMoveAllEntriesDto)
        {
            if (fileManagerMoveAllEntriesDto.IsSet && fileManagerMoveAllEntriesDto.Value == null)
                throw new ArgumentNullException(nameof(fileManagerMoveAllEntriesDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerMoveAllEntriesDto"></param>
        private void AfterFileManagerFileMoveAllEntriesDefaultImplementation(IFileManagerFileMoveAllEntriesApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerMoveAllEntriesDto> fileManagerMoveAllEntriesDto)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileMoveAllEntries(ref suppressDefaultLog, apiResponseLocalVar, archiveId, type, fileManagerMoveAllEntriesDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerMoveAllEntriesDto"></param>
        partial void AfterFileManagerFileMoveAllEntries(ref bool suppressDefaultLog, IFileManagerFileMoveAllEntriesApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerMoveAllEntriesDto> fileManagerMoveAllEntriesDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerMoveAllEntriesDto"></param>
        private void OnErrorFileManagerFileMoveAllEntriesDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerMoveAllEntriesDto> fileManagerMoveAllEntriesDto)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileMoveAllEntries(ref suppressDefaultLog, exception, pathFormat, path, archiveId, type, fileManagerMoveAllEntriesDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerMoveAllEntriesDto"></param>
        partial void OnErrorFileManagerFileMoveAllEntries(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerMoveAllEntriesDto> fileManagerMoveAllEntriesDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerMoveAllEntriesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileMoveAllEntriesApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileMoveAllEntriesApiResponse> FileManagerFileMoveAllEntriesOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerMoveAllEntriesDto> fileManagerMoveAllEntriesDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileMoveAllEntriesAsync(archiveId, type, fileManagerMoveAllEntriesDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerMoveAllEntriesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileMoveAllEntriesApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileMoveAllEntriesApiResponse> FileManagerFileMoveAllEntriesAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerMoveAllEntriesDto> fileManagerMoveAllEntriesDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileMoveAllEntries(fileManagerMoveAllEntriesDto);

                FormatFileManagerFileMoveAllEntries(ref archiveId, ref type, fileManagerMoveAllEntriesDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/MoveAllEntries";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (fileManagerMoveAllEntriesDto.IsSet)
                        httpRequestMessageLocalVar.Content = (fileManagerMoveAllEntriesDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(fileManagerMoveAllEntriesDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileMoveAllEntriesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileMoveAllEntriesApiResponse>();

                        FileManagerFileMoveAllEntriesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/MoveAllEntries", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileMoveAllEntriesDefaultImplementation(apiResponseLocalVar, archiveId, type, fileManagerMoveAllEntriesDto);

                        Events.ExecuteOnFileManagerFileMoveAllEntries(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileMoveAllEntriesDefaultImplementation(e, "/api/file-manager/files/MoveAllEntries", uriBuilderLocalVar.Path, archiveId, type, fileManagerMoveAllEntriesDto);
                Events.ExecuteOnErrorFileManagerFileMoveAllEntries(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileMoveAllEntriesApiResponse"/>
        /// </summary>
        public partial class FileManagerFileMoveAllEntriesApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileMoveAllEntriesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileMoveAllEntriesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileMoveAllEntriesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileMoveAllEntriesApiResponse(ILogger<FileManagerFileMoveAllEntriesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileMoveEntry(ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerMoveEntryDto> fileManagerMoveEntryDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileManagerMoveEntryDto"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileMoveEntry(Option<FileManagerMoveEntryDto> fileManagerMoveEntryDto)
        {
            if (fileManagerMoveEntryDto.IsSet && fileManagerMoveEntryDto.Value == null)
                throw new ArgumentNullException(nameof(fileManagerMoveEntryDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerMoveEntryDto"></param>
        private void AfterFileManagerFileMoveEntryDefaultImplementation(IFileManagerFileMoveEntryApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerMoveEntryDto> fileManagerMoveEntryDto)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileMoveEntry(ref suppressDefaultLog, apiResponseLocalVar, archiveId, type, fileManagerMoveEntryDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerMoveEntryDto"></param>
        partial void AfterFileManagerFileMoveEntry(ref bool suppressDefaultLog, IFileManagerFileMoveEntryApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerMoveEntryDto> fileManagerMoveEntryDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerMoveEntryDto"></param>
        private void OnErrorFileManagerFileMoveEntryDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerMoveEntryDto> fileManagerMoveEntryDto)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileMoveEntry(ref suppressDefaultLog, exception, pathFormat, path, archiveId, type, fileManagerMoveEntryDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerMoveEntryDto"></param>
        partial void OnErrorFileManagerFileMoveEntry(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerMoveEntryDto> fileManagerMoveEntryDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerMoveEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileMoveEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileMoveEntryApiResponse> FileManagerFileMoveEntryOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerMoveEntryDto> fileManagerMoveEntryDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileMoveEntryAsync(archiveId, type, fileManagerMoveEntryDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerMoveEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileMoveEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileMoveEntryApiResponse> FileManagerFileMoveEntryAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerMoveEntryDto> fileManagerMoveEntryDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileMoveEntry(fileManagerMoveEntryDto);

                FormatFileManagerFileMoveEntry(ref archiveId, ref type, fileManagerMoveEntryDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/MoveEntry";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (fileManagerMoveEntryDto.IsSet)
                        httpRequestMessageLocalVar.Content = (fileManagerMoveEntryDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(fileManagerMoveEntryDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileMoveEntryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileMoveEntryApiResponse>();

                        FileManagerFileMoveEntryApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/MoveEntry", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileMoveEntryDefaultImplementation(apiResponseLocalVar, archiveId, type, fileManagerMoveEntryDto);

                        Events.ExecuteOnFileManagerFileMoveEntry(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileMoveEntryDefaultImplementation(e, "/api/file-manager/files/MoveEntry", uriBuilderLocalVar.Path, archiveId, type, fileManagerMoveEntryDto);
                Events.ExecuteOnErrorFileManagerFileMoveEntry(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileMoveEntryApiResponse"/>
        /// </summary>
        public partial class FileManagerFileMoveEntryApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileMoveEntryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileMoveEntryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileMoveEntryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileMoveEntryApiResponse(ILogger<FileManagerFileMoveEntryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileReadTextFile(ref Option<string> id, ref Option<bool> isVersion, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileReadTextFile(Option<string> id)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileReadTextFileDefaultImplementation(IFileManagerFileReadTextFileApiResponse apiResponseLocalVar, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileReadTextFile(ref suppressDefaultLog, apiResponseLocalVar, id, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileReadTextFile(ref bool suppressDefaultLog, IFileManagerFileReadTextFileApiResponse apiResponseLocalVar, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileReadTextFileDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileReadTextFile(ref suppressDefaultLog, exception, pathFormat, path, id, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileReadTextFile(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileReadTextFileApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileReadTextFileApiResponse> FileManagerFileReadTextFileOrDefaultAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileReadTextFileAsync(id, isVersion, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileReadTextFileApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileReadTextFileApiResponse> FileManagerFileReadTextFileAsync(Option<string> id = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileReadTextFile(id);

                FormatFileManagerFileReadTextFile(ref id, ref isVersion, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/ReadTextFile";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (isVersion.IsSet)
                        parseQueryStringLocalVar["isVersion"] = ClientUtils.ParameterToString(isVersion.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileReadTextFileApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileReadTextFileApiResponse>();

                        FileManagerFileReadTextFileApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/ReadTextFile", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileReadTextFileDefaultImplementation(apiResponseLocalVar, id, isVersion, archiveId, type);

                        Events.ExecuteOnFileManagerFileReadTextFile(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileReadTextFileDefaultImplementation(e, "/api/file-manager/files/ReadTextFile", uriBuilderLocalVar.Path, id, isVersion, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileReadTextFile(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileReadTextFileApiResponse"/>
        /// </summary>
        public partial class FileManagerFileReadTextFileApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileReadTextFileApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileReadTextFileApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileReadTextFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileReadTextFileApiResponse(ILogger<FileManagerFileReadTextFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<string> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<string>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<string> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileReadTextFileByToken(ref Option<string> id, ref Option<string> token, ref Option<bool> isVersion, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileReadTextFileByToken(Option<string> id, Option<string> token)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));

            if (token.IsSet && token.Value == null)
                throw new ArgumentNullException(nameof(token));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileReadTextFileByTokenDefaultImplementation(IFileManagerFileReadTextFileByTokenApiResponse apiResponseLocalVar, Option<string> id, Option<string> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileReadTextFileByToken(ref suppressDefaultLog, apiResponseLocalVar, id, token, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileReadTextFileByToken(ref bool suppressDefaultLog, IFileManagerFileReadTextFileByTokenApiResponse apiResponseLocalVar, Option<string> id, Option<string> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileReadTextFileByTokenDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<string> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileReadTextFileByToken(ref suppressDefaultLog, exception, pathFormat, path, id, token, isVersion, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="token"></param>
        /// <param name="isVersion"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileReadTextFileByToken(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<string> token, Option<bool> isVersion, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileReadTextFileByTokenApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileReadTextFileByTokenApiResponse> FileManagerFileReadTextFileByTokenOrDefaultAsync(Option<string> id = default, Option<string> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileReadTextFileByTokenAsync(id, token, isVersion, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="token"> (optional)</param>
        /// <param name="isVersion"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileReadTextFileByTokenApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileReadTextFileByTokenApiResponse> FileManagerFileReadTextFileByTokenAsync(Option<string> id = default, Option<string> token = default, Option<bool> isVersion = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileReadTextFileByToken(id, token);

                FormatFileManagerFileReadTextFileByToken(ref id, ref token, ref isVersion, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/ReadTextFileByToken";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (token.IsSet)
                        parseQueryStringLocalVar["token"] = ClientUtils.ParameterToString(token.Value);

                    if (isVersion.IsSet)
                        parseQueryStringLocalVar["isVersion"] = ClientUtils.ParameterToString(isVersion.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileReadTextFileByTokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileReadTextFileByTokenApiResponse>();

                        FileManagerFileReadTextFileByTokenApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/ReadTextFileByToken", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileReadTextFileByTokenDefaultImplementation(apiResponseLocalVar, id, token, isVersion, archiveId, type);

                        Events.ExecuteOnFileManagerFileReadTextFileByToken(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileReadTextFileByTokenDefaultImplementation(e, "/api/file-manager/files/ReadTextFileByToken", uriBuilderLocalVar.Path, id, token, isVersion, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileReadTextFileByToken(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileReadTextFileByTokenApiResponse"/>
        /// </summary>
        public partial class FileManagerFileReadTextFileByTokenApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileReadTextFileByTokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileReadTextFileByTokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileReadTextFileByTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileReadTextFileByTokenApiResponse(ILogger<FileManagerFileReadTextFileByTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<string> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<string>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<string> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileRenameEntry(ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerRenameEntryDto> fileManagerRenameEntryDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileManagerRenameEntryDto"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileRenameEntry(Option<FileManagerRenameEntryDto> fileManagerRenameEntryDto)
        {
            if (fileManagerRenameEntryDto.IsSet && fileManagerRenameEntryDto.Value == null)
                throw new ArgumentNullException(nameof(fileManagerRenameEntryDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerRenameEntryDto"></param>
        private void AfterFileManagerFileRenameEntryDefaultImplementation(IFileManagerFileRenameEntryApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerRenameEntryDto> fileManagerRenameEntryDto)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileRenameEntry(ref suppressDefaultLog, apiResponseLocalVar, archiveId, type, fileManagerRenameEntryDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerRenameEntryDto"></param>
        partial void AfterFileManagerFileRenameEntry(ref bool suppressDefaultLog, IFileManagerFileRenameEntryApiResponse apiResponseLocalVar, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerRenameEntryDto> fileManagerRenameEntryDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerRenameEntryDto"></param>
        private void OnErrorFileManagerFileRenameEntryDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerRenameEntryDto> fileManagerRenameEntryDto)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileRenameEntry(ref suppressDefaultLog, exception, pathFormat, path, archiveId, type, fileManagerRenameEntryDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        /// <param name="fileManagerRenameEntryDto"></param>
        partial void OnErrorFileManagerFileRenameEntry(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type, Option<FileManagerRenameEntryDto> fileManagerRenameEntryDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerRenameEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileRenameEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileRenameEntryApiResponse> FileManagerFileRenameEntryOrDefaultAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerRenameEntryDto> fileManagerRenameEntryDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileRenameEntryAsync(archiveId, type, fileManagerRenameEntryDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="fileManagerRenameEntryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileRenameEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileRenameEntryApiResponse> FileManagerFileRenameEntryAsync(Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, Option<FileManagerRenameEntryDto> fileManagerRenameEntryDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileRenameEntry(fileManagerRenameEntryDto);

                FormatFileManagerFileRenameEntry(ref archiveId, ref type, fileManagerRenameEntryDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/RenameEntry";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (fileManagerRenameEntryDto.IsSet)
                        httpRequestMessageLocalVar.Content = (fileManagerRenameEntryDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(fileManagerRenameEntryDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileRenameEntryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileRenameEntryApiResponse>();

                        FileManagerFileRenameEntryApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/RenameEntry", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileRenameEntryDefaultImplementation(apiResponseLocalVar, archiveId, type, fileManagerRenameEntryDto);

                        Events.ExecuteOnFileManagerFileRenameEntry(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileRenameEntryDefaultImplementation(e, "/api/file-manager/files/RenameEntry", uriBuilderLocalVar.Path, archiveId, type, fileManagerRenameEntryDto);
                Events.ExecuteOnErrorFileManagerFileRenameEntry(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileRenameEntryApiResponse"/>
        /// </summary>
        public partial class FileManagerFileRenameEntryApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileRenameEntryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileRenameEntryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileRenameEntryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileRenameEntryApiResponse(ILogger<FileManagerFileRenameEntryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.FileManagerFileSystemEntryDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.FileManagerFileSystemEntryDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleonsoftProxy.Model.FileManagerFileSystemEntryDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileRestoreEntry(ref Option<string> id, ref Option<Guid> archiveId, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileRestoreEntry(Option<string> id)
        {
            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileRestoreEntryDefaultImplementation(IFileManagerFileRestoreEntryApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileRestoreEntry(ref suppressDefaultLog, apiResponseLocalVar, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileRestoreEntry(ref bool suppressDefaultLog, IFileManagerFileRestoreEntryApiResponse apiResponseLocalVar, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileRestoreEntryDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileRestoreEntry(ref suppressDefaultLog, exception, pathFormat, path, id, archiveId, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="id"></param>
        /// <param name="archiveId"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileRestoreEntry(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> id, Option<Guid> archiveId, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileRestoreEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileRestoreEntryApiResponse> FileManagerFileRestoreEntryOrDefaultAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileRestoreEntryAsync(id, archiveId, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileRestoreEntryApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileRestoreEntryApiResponse> FileManagerFileRestoreEntryAsync(Option<string> id = default, Option<Guid> archiveId = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileRestoreEntry(id);

                FormatFileManagerFileRestoreEntry(ref id, ref archiveId, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/RestoreEntry";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileRestoreEntryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileRestoreEntryApiResponse>();

                        FileManagerFileRestoreEntryApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/RestoreEntry", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileRestoreEntryDefaultImplementation(apiResponseLocalVar, id, archiveId, type);

                        Events.ExecuteOnFileManagerFileRestoreEntry(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileRestoreEntryDefaultImplementation(e, "/api/file-manager/files/RestoreEntry", uriBuilderLocalVar.Path, id, archiveId, type);
                Events.ExecuteOnErrorFileManagerFileRestoreEntry(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileRestoreEntryApiResponse"/>
        /// </summary>
        public partial class FileManagerFileRestoreEntryApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileRestoreEntryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileRestoreEntryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileRestoreEntryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileRestoreEntryApiResponse(ILogger<FileManagerFileRestoreEntryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileSearchEntries(ref Option<string> search, ref Option<Guid> archiveId, ref Option<FileManagerEntryKind> kind, ref Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="search"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileSearchEntries(Option<string> search)
        {
            if (search.IsSet && search.Value == null)
                throw new ArgumentNullException(nameof(search));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="search"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="type"></param>
        private void AfterFileManagerFileSearchEntriesDefaultImplementation(IFileManagerFileSearchEntriesApiResponse apiResponseLocalVar, Option<string> search, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileSearchEntries(ref suppressDefaultLog, apiResponseLocalVar, search, archiveId, kind, type);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="search"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="type"></param>
        partial void AfterFileManagerFileSearchEntries(ref bool suppressDefaultLog, IFileManagerFileSearchEntriesApiResponse apiResponseLocalVar, Option<string> search, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="search"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="type"></param>
        private void OnErrorFileManagerFileSearchEntriesDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> search, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<EleonsoftModuleCollectorFileManagerType> type)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileSearchEntries(ref suppressDefaultLog, exception, pathFormat, path, search, archiveId, kind, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="search"></param>
        /// <param name="archiveId"></param>
        /// <param name="kind"></param>
        /// <param name="type"></param>
        partial void OnErrorFileManagerFileSearchEntries(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> search, Option<Guid> archiveId, Option<FileManagerEntryKind> kind, Option<EleonsoftModuleCollectorFileManagerType> type);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="search"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileSearchEntriesApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileSearchEntriesApiResponse> FileManagerFileSearchEntriesOrDefaultAsync(Option<string> search = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileSearchEntriesAsync(search, archiveId, kind, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="search"> (optional)</param>
        /// <param name="archiveId"> (optional)</param>
        /// <param name="kind"> (optional)</param>
        /// <param name="type"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileSearchEntriesApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileSearchEntriesApiResponse> FileManagerFileSearchEntriesAsync(Option<string> search = default, Option<Guid> archiveId = default, Option<FileManagerEntryKind> kind = default, Option<EleonsoftModuleCollectorFileManagerType> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileSearchEntries(search);

                FormatFileManagerFileSearchEntries(ref search, ref archiveId, ref kind, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/SearchEntries";


                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (search.IsSet)
                        parseQueryStringLocalVar["search"] = ClientUtils.ParameterToString(search.Value);

                    if (archiveId.IsSet)
                        parseQueryStringLocalVar["archiveId"] = ClientUtils.ParameterToString(archiveId.Value);

                    if (kind.IsSet)
                        parseQueryStringLocalVar["kind"] = ClientUtils.ParameterToString(kind.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileSearchEntriesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileSearchEntriesApiResponse>();

                        FileManagerFileSearchEntriesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/SearchEntries", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileSearchEntriesDefaultImplementation(apiResponseLocalVar, search, archiveId, kind, type);

                        Events.ExecuteOnFileManagerFileSearchEntries(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileSearchEntriesDefaultImplementation(e, "/api/file-manager/files/SearchEntries", uriBuilderLocalVar.Path, search, archiveId, kind, type);
                Events.ExecuteOnErrorFileManagerFileSearchEntries(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileSearchEntriesApiResponse"/>
        /// </summary>
        public partial class FileManagerFileSearchEntriesApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileSearchEntriesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileSearchEntriesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileSearchEntriesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileSearchEntriesApiResponse(ILogger<FileManagerFileSearchEntriesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<FileManagerFileSystemEntryDto> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<FileManagerFileSystemEntryDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<FileManagerFileSystemEntryDto> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFileManagerFileUploadFiles(Option<FileManagerFileUploadDto> fileManagerFileUploadDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileManagerFileUploadDto"></param>
        /// <returns></returns>
        private void ValidateFileManagerFileUploadFiles(Option<FileManagerFileUploadDto> fileManagerFileUploadDto)
        {
            if (fileManagerFileUploadDto.IsSet && fileManagerFileUploadDto.Value == null)
                throw new ArgumentNullException(nameof(fileManagerFileUploadDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileManagerFileUploadDto"></param>
        private void AfterFileManagerFileUploadFilesDefaultImplementation(IFileManagerFileUploadFilesApiResponse apiResponseLocalVar, Option<FileManagerFileUploadDto> fileManagerFileUploadDto)
        {
            bool suppressDefaultLog = false;
            AfterFileManagerFileUploadFiles(ref suppressDefaultLog, apiResponseLocalVar, fileManagerFileUploadDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileManagerFileUploadDto"></param>
        partial void AfterFileManagerFileUploadFiles(ref bool suppressDefaultLog, IFileManagerFileUploadFilesApiResponse apiResponseLocalVar, Option<FileManagerFileUploadDto> fileManagerFileUploadDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="fileManagerFileUploadDto"></param>
        private void OnErrorFileManagerFileUploadFilesDefaultImplementation(Exception exception, string pathFormat, string path, Option<FileManagerFileUploadDto> fileManagerFileUploadDto)
        {
            bool suppressDefaultLog = false;
            OnErrorFileManagerFileUploadFiles(ref suppressDefaultLog, exception, pathFormat, path, fileManagerFileUploadDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="fileManagerFileUploadDto"></param>
        partial void OnErrorFileManagerFileUploadFiles(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<FileManagerFileUploadDto> fileManagerFileUploadDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="fileManagerFileUploadDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileUploadFilesApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileUploadFilesApiResponse> FileManagerFileUploadFilesOrDefaultAsync(Option<FileManagerFileUploadDto> fileManagerFileUploadDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FileManagerFileUploadFilesAsync(fileManagerFileUploadDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileManagerFileUploadDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFileManagerFileUploadFilesApiResponse"/>&gt;</returns>
        public async Task<IFileManagerFileUploadFilesApiResponse> FileManagerFileUploadFilesAsync(Option<FileManagerFileUploadDto> fileManagerFileUploadDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "FileApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateFileManagerFileUploadFiles(fileManagerFileUploadDto);

                FormatFileManagerFileUploadFiles(fileManagerFileUploadDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/file-manager/files/UploadFiles";


                    if (fileManagerFileUploadDto.IsSet)
                        httpRequestMessageLocalVar.Content = (fileManagerFileUploadDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(fileManagerFileUploadDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;


                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);


                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<FileManagerFileUploadFilesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FileManagerFileUploadFilesApiResponse>();

                        FileManagerFileUploadFilesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/file-manager/files/UploadFiles", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFileManagerFileUploadFilesDefaultImplementation(apiResponseLocalVar, fileManagerFileUploadDto);

                        Events.ExecuteOnFileManagerFileUploadFiles(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFileManagerFileUploadFilesDefaultImplementation(e, "/api/file-manager/files/UploadFiles", uriBuilderLocalVar.Path, fileManagerFileUploadDto);
                Events.ExecuteOnErrorFileManagerFileUploadFiles(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FileManagerFileUploadFilesApiResponse"/>
        /// </summary>
        public partial class FileManagerFileUploadFilesApiResponse : EleonsoftProxy.Client.ApiResponse, IFileManagerFileUploadFilesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FileManagerFileUploadFilesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FileManagerFileUploadFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FileManagerFileUploadFilesApiResponse(ILogger<FileManagerFileUploadFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<FileManagerFileSystemEntryDto> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<FileManagerFileSystemEntryDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<FileManagerFileSystemEntryDto> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleonsoftProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}

