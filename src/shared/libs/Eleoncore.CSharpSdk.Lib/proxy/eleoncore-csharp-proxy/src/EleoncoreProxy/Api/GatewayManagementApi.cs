// <auto-generated>
/*
 * Eleoncore API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using SharedModule.HttpApi.Helpers;
using Microsoft.AspNetCore.Http;
using EleoncoreProxy.Client;
using EleoncoreProxy.Model;
using System.Diagnostics.CodeAnalysis;

namespace EleoncoreProxy.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IGatewayManagementApi : IApi
    {
        void UseOAuthAuth();
        void UseApiAuth();
		void UseDefaultAuth();

        /// <summary>
        /// The class containing the events
        /// </summary>
        GatewayManagementApiEvents Events { get; }

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayManagementAcceptPendingGatewayRequestDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse> GatewayManagementGatewayManagementAcceptPendingGatewayAsync(Option<GatewayManagementAcceptPendingGatewayRequestDto> gatewayManagementAcceptPendingGatewayRequestDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="gatewayManagementAcceptPendingGatewayRequestDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse> GatewayManagementGatewayManagementAcceptPendingGatewayOrDefaultAsync(Option<GatewayManagementAcceptPendingGatewayRequestDto> gatewayManagementAcceptPendingGatewayRequestDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayManagementGatewayDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementAddGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementAddGatewayApiResponse> GatewayManagementGatewayManagementAddGatewayAsync(Option<GatewayManagementGatewayDto> gatewayManagementGatewayDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="gatewayManagementGatewayDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementAddGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementAddGatewayApiResponse> GatewayManagementGatewayManagementAddGatewayOrDefaultAsync(Option<GatewayManagementGatewayDto> gatewayManagementGatewayDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse> GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse> GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse> GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse> GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementGetGatewayApiResponse> GatewayManagementGatewayManagementGetGatewayAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementGetGatewayApiResponse> GatewayManagementGatewayManagementGetGatewayOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="statusFilter"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetGatewayListApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementGetGatewayListApiResponse> GatewayManagementGatewayManagementGetGatewayListAsync(Option<EleoncoreGatewayStatus> statusFilter = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="statusFilter"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetGatewayListApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementGetGatewayListApiResponse> GatewayManagementGatewayManagementGetGatewayListOrDefaultAsync(Option<EleoncoreGatewayStatus> statusFilter = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse> GatewayManagementGatewayManagementRejectPendingGatewayAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse> GatewayManagementGatewayManagementRejectPendingGatewayOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRemoveGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementRemoveGatewayApiResponse> GatewayManagementGatewayManagementRemoveGatewayAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRemoveGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementRemoveGatewayApiResponse> GatewayManagementGatewayManagementRemoveGatewayOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse> GatewayManagementGatewayManagementRequestGatewayRegistrationAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse> GatewayManagementGatewayManagementRequestGatewayRegistrationOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayManagementUpdateGatewayRequestDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementUpdateGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementUpdateGatewayApiResponse> GatewayManagementGatewayManagementUpdateGatewayAsync(Option<GatewayManagementUpdateGatewayRequestDto> gatewayManagementUpdateGatewayRequestDto = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="gatewayManagementUpdateGatewayRequestDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementUpdateGatewayApiResponse"/>&gt;</returns>
        Task<IGatewayManagementGatewayManagementUpdateGatewayApiResponse> GatewayManagementGatewayManagementUpdateGatewayOrDefaultAsync(Option<GatewayManagementUpdateGatewayRequestDto> gatewayManagementUpdateGatewayRequestDto = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse"/>
    /// </summary>
    public interface IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse : EleoncoreProxy.Client.IApiResponse, IForbidden<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGatewayManagementGatewayManagementAddGatewayApiResponse"/>
    /// </summary>
    public interface IGatewayManagementGatewayManagementAddGatewayApiResponse : EleoncoreProxy.Client.IApiResponse, IOk<string>, IForbidden<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse"/>
    /// </summary>
    public interface IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse : EleoncoreProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse"/>
    /// </summary>
    public interface IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse : EleoncoreProxy.Client.IApiResponse, IOk<EleoncoreProxy.Model.GatewayManagementGatewayRegistrationKeyDto>, IForbidden<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGatewayManagementGatewayManagementGetGatewayApiResponse"/>
    /// </summary>
    public interface IGatewayManagementGatewayManagementGetGatewayApiResponse : EleoncoreProxy.Client.IApiResponse, IOk<EleoncoreProxy.Model.GatewayManagementGatewayDto>, IForbidden<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGatewayManagementGatewayManagementGetGatewayListApiResponse"/>
    /// </summary>
    public interface IGatewayManagementGatewayManagementGetGatewayListApiResponse : EleoncoreProxy.Client.IApiResponse, IOk<List<GatewayManagementGatewayDto>>, IForbidden<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse"/>
    /// </summary>
    public interface IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse : EleoncoreProxy.Client.IApiResponse, IForbidden<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGatewayManagementGatewayManagementRemoveGatewayApiResponse"/>
    /// </summary>
    public interface IGatewayManagementGatewayManagementRemoveGatewayApiResponse : EleoncoreProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse"/>
    /// </summary>
    public interface IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse : EleoncoreProxy.Client.IApiResponse, IOk<EleoncoreProxy.Model.GatewayManagementGatewayRegistrationKeyDto>, IForbidden<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGatewayManagementGatewayManagementUpdateGatewayApiResponse"/>
    /// </summary>
    public interface IGatewayManagementGatewayManagementUpdateGatewayApiResponse : EleoncoreProxy.Client.IApiResponse, IOk<bool?>, IForbidden<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IUnauthorized<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IBadRequest<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotFound<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, INotImplemented<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>, IInternalServerError<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 501 NotImplemented
        /// </summary>
        /// <returns></returns>
        bool IsNotImplemented { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class GatewayManagementApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGatewayManagementGatewayManagementAcceptPendingGateway;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGatewayManagementGatewayManagementAcceptPendingGateway;

        internal void ExecuteOnGatewayManagementGatewayManagementAcceptPendingGateway(GatewayManagementApi.GatewayManagementGatewayManagementAcceptPendingGatewayApiResponse apiResponse)
        {
            OnGatewayManagementGatewayManagementAcceptPendingGateway?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGatewayManagementGatewayManagementAcceptPendingGateway(Exception exception)
        {
            OnErrorGatewayManagementGatewayManagementAcceptPendingGateway?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGatewayManagementGatewayManagementAddGateway;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGatewayManagementGatewayManagementAddGateway;

        internal void ExecuteOnGatewayManagementGatewayManagementAddGateway(GatewayManagementApi.GatewayManagementGatewayManagementAddGatewayApiResponse apiResponse)
        {
            OnGatewayManagementGatewayManagementAddGateway?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGatewayManagementGatewayManagementAddGateway(Exception exception)
        {
            OnErrorGatewayManagementGatewayManagementAddGateway?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGatewayManagementGatewayManagementCancelOngoingGatewayRegistration;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGatewayManagementGatewayManagementCancelOngoingGatewayRegistration;

        internal void ExecuteOnGatewayManagementGatewayManagementCancelOngoingGatewayRegistration(GatewayManagementApi.GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse apiResponse)
        {
            OnGatewayManagementGatewayManagementCancelOngoingGatewayRegistration?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGatewayManagementGatewayManagementCancelOngoingGatewayRegistration(Exception exception)
        {
            OnErrorGatewayManagementGatewayManagementCancelOngoingGatewayRegistration?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey;

        internal void ExecuteOnGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey(GatewayManagementApi.GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse apiResponse)
        {
            OnGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey(Exception exception)
        {
            OnErrorGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGatewayManagementGatewayManagementGetGateway;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGatewayManagementGatewayManagementGetGateway;

        internal void ExecuteOnGatewayManagementGatewayManagementGetGateway(GatewayManagementApi.GatewayManagementGatewayManagementGetGatewayApiResponse apiResponse)
        {
            OnGatewayManagementGatewayManagementGetGateway?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGatewayManagementGatewayManagementGetGateway(Exception exception)
        {
            OnErrorGatewayManagementGatewayManagementGetGateway?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGatewayManagementGatewayManagementGetGatewayList;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGatewayManagementGatewayManagementGetGatewayList;

        internal void ExecuteOnGatewayManagementGatewayManagementGetGatewayList(GatewayManagementApi.GatewayManagementGatewayManagementGetGatewayListApiResponse apiResponse)
        {
            OnGatewayManagementGatewayManagementGetGatewayList?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGatewayManagementGatewayManagementGetGatewayList(Exception exception)
        {
            OnErrorGatewayManagementGatewayManagementGetGatewayList?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGatewayManagementGatewayManagementRejectPendingGateway;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGatewayManagementGatewayManagementRejectPendingGateway;

        internal void ExecuteOnGatewayManagementGatewayManagementRejectPendingGateway(GatewayManagementApi.GatewayManagementGatewayManagementRejectPendingGatewayApiResponse apiResponse)
        {
            OnGatewayManagementGatewayManagementRejectPendingGateway?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGatewayManagementGatewayManagementRejectPendingGateway(Exception exception)
        {
            OnErrorGatewayManagementGatewayManagementRejectPendingGateway?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGatewayManagementGatewayManagementRemoveGateway;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGatewayManagementGatewayManagementRemoveGateway;

        internal void ExecuteOnGatewayManagementGatewayManagementRemoveGateway(GatewayManagementApi.GatewayManagementGatewayManagementRemoveGatewayApiResponse apiResponse)
        {
            OnGatewayManagementGatewayManagementRemoveGateway?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGatewayManagementGatewayManagementRemoveGateway(Exception exception)
        {
            OnErrorGatewayManagementGatewayManagementRemoveGateway?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGatewayManagementGatewayManagementRequestGatewayRegistration;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGatewayManagementGatewayManagementRequestGatewayRegistration;

        internal void ExecuteOnGatewayManagementGatewayManagementRequestGatewayRegistration(GatewayManagementApi.GatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse apiResponse)
        {
            OnGatewayManagementGatewayManagementRequestGatewayRegistration?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGatewayManagementGatewayManagementRequestGatewayRegistration(Exception exception)
        {
            OnErrorGatewayManagementGatewayManagementRequestGatewayRegistration?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGatewayManagementGatewayManagementUpdateGateway;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGatewayManagementGatewayManagementUpdateGateway;

        internal void ExecuteOnGatewayManagementGatewayManagementUpdateGateway(GatewayManagementApi.GatewayManagementGatewayManagementUpdateGatewayApiResponse apiResponse)
        {
            OnGatewayManagementGatewayManagementUpdateGateway?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGatewayManagementGatewayManagementUpdateGateway(Exception exception)
        {
            OnErrorGatewayManagementGatewayManagementUpdateGateway?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class GatewayManagementApi : IGatewayManagementApi
    {
		public HttpClient HttpClient => SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, GetType().Name);
	
		private readonly EleoncoreSdkConfig _sdkConfig;
        private readonly JsonSerializerOptions _jsonSerializerOptions;
		private readonly ApiConfigurator _apiConfigurator;
		
		private string _accessTokenType;

        private readonly ILoggerFactory LoggerFactory;
        private readonly ILogger<GatewayManagementApi> Logger;

        /// <summary>
        /// The class containing the events
        /// </summary>
        public GatewayManagementApiEvents Events { get; }
		
		/// <summary>
        /// Initializes a new instance of the <see cref="GatewayManagementApi"/> class.
        /// </summary>
        /// <returns></returns>
        public GatewayManagementApi() : this(ApiConfigurator.GetConfigurator("EleoncoreProxy"))
        {
        }
		
		
        /// <summary>
        /// Initializes a new instance of the <see cref="GatewayManagementApi"/> class.
        /// </summary>
        /// <returns></returns>
        public GatewayManagementApi(ApiConfigurator apiConfigurator)
        {
			apiConfigurator.Validate();
		
			_apiConfigurator = apiConfigurator;
            _sdkConfig = apiConfigurator.SdkConfig;
            _jsonSerializerOptions = apiConfigurator.JsonSerializerOptions;
            LoggerFactory = apiConfigurator.LoggerFactory;
            Logger = LoggerFactory.CreateLogger<GatewayManagementApi>();
            Events = new GatewayManagementApiEvents();
			
        }
        

        /// <summary>
        /// Switch to use API Authorization dynamically.
        /// </summary>
        public void UseApiAuth()
		{
			if (!_sdkConfig.UseApiAuthorization)
			{
				throw new Exception("API Authorization is not configured in the SDK.");
			}

			_accessTokenType = "api";
		}

        /// <summary>
        /// Switch to use OAuth Authorization dynamically.
        /// </summary>
        public void UseOAuthAuth()
        {
            if (!_sdkConfig.UseOAuthAuthorization)
            {
                throw new Exception("OAuth Authorization is not configured in the SDK.");
            }

            _accessTokenType = "oauth";
        }
		
		public void UseDefaultAuth()
		{
			_accessTokenType = string.Empty;
		}

        public string GetBaseUrl()
		{
			if (_accessTokenType == "api" && _sdkConfig.UseApiAuthorization)
			{
				return _sdkConfig.ApiAuthUrl;
			}

			if ((_accessTokenType == "oauth" || string.IsNullOrEmpty(_accessTokenType)) && _sdkConfig.UseOAuthAuthorization)
			{
				return _sdkConfig.OAuthUrl;
			}
			
			throw new Exception("No valid authorization mode is configured or enabled.");
		}
		
		

        partial void FormatGatewayManagementGatewayManagementAcceptPendingGateway(Option<GatewayManagementAcceptPendingGatewayRequestDto> gatewayManagementAcceptPendingGatewayRequestDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="gatewayManagementAcceptPendingGatewayRequestDto"></param>
        /// <returns></returns>
        private void ValidateGatewayManagementGatewayManagementAcceptPendingGateway(Option<GatewayManagementAcceptPendingGatewayRequestDto> gatewayManagementAcceptPendingGatewayRequestDto)
        {
            if (gatewayManagementAcceptPendingGatewayRequestDto.IsSet && gatewayManagementAcceptPendingGatewayRequestDto.Value == null)
                throw new ArgumentNullException(nameof(gatewayManagementAcceptPendingGatewayRequestDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayManagementAcceptPendingGatewayRequestDto"></param>
        private void AfterGatewayManagementGatewayManagementAcceptPendingGatewayDefaultImplementation(IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse apiResponseLocalVar, Option<GatewayManagementAcceptPendingGatewayRequestDto> gatewayManagementAcceptPendingGatewayRequestDto)
        {
            bool suppressDefaultLog = false;
            AfterGatewayManagementGatewayManagementAcceptPendingGateway(ref suppressDefaultLog, apiResponseLocalVar, gatewayManagementAcceptPendingGatewayRequestDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayManagementAcceptPendingGatewayRequestDto"></param>
        partial void AfterGatewayManagementGatewayManagementAcceptPendingGateway(ref bool suppressDefaultLog, IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse apiResponseLocalVar, Option<GatewayManagementAcceptPendingGatewayRequestDto> gatewayManagementAcceptPendingGatewayRequestDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayManagementAcceptPendingGatewayRequestDto"></param>
        private void OnErrorGatewayManagementGatewayManagementAcceptPendingGatewayDefaultImplementation(Exception exception, string pathFormat, string path, Option<GatewayManagementAcceptPendingGatewayRequestDto> gatewayManagementAcceptPendingGatewayRequestDto)
        {
            bool suppressDefaultLog = false;
            OnErrorGatewayManagementGatewayManagementAcceptPendingGateway(ref suppressDefaultLog, exception, pathFormat, path, gatewayManagementAcceptPendingGatewayRequestDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayManagementAcceptPendingGatewayRequestDto"></param>
        partial void OnErrorGatewayManagementGatewayManagementAcceptPendingGateway(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<GatewayManagementAcceptPendingGatewayRequestDto> gatewayManagementAcceptPendingGatewayRequestDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="gatewayManagementAcceptPendingGatewayRequestDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse> GatewayManagementGatewayManagementAcceptPendingGatewayOrDefaultAsync(Option<GatewayManagementAcceptPendingGatewayRequestDto> gatewayManagementAcceptPendingGatewayRequestDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GatewayManagementGatewayManagementAcceptPendingGatewayAsync(gatewayManagementAcceptPendingGatewayRequestDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayManagementAcceptPendingGatewayRequestDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse> GatewayManagementGatewayManagementAcceptPendingGatewayAsync(Option<GatewayManagementAcceptPendingGatewayRequestDto> gatewayManagementAcceptPendingGatewayRequestDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "GatewayManagementApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateGatewayManagementGatewayManagementAcceptPendingGateway(gatewayManagementAcceptPendingGatewayRequestDto);

                FormatGatewayManagementGatewayManagementAcceptPendingGateway(gatewayManagementAcceptPendingGatewayRequestDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/GatewayManagement/GatewayManagement/AcceptPendingGateway";

                    if (gatewayManagementAcceptPendingGatewayRequestDto.IsSet)
                        httpRequestMessageLocalVar.Content = (gatewayManagementAcceptPendingGatewayRequestDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(gatewayManagementAcceptPendingGatewayRequestDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GatewayManagementGatewayManagementAcceptPendingGatewayApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GatewayManagementGatewayManagementAcceptPendingGatewayApiResponse>();

                        GatewayManagementGatewayManagementAcceptPendingGatewayApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/GatewayManagement/GatewayManagement/AcceptPendingGateway", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGatewayManagementGatewayManagementAcceptPendingGatewayDefaultImplementation(apiResponseLocalVar, gatewayManagementAcceptPendingGatewayRequestDto);

                        Events.ExecuteOnGatewayManagementGatewayManagementAcceptPendingGateway(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGatewayManagementGatewayManagementAcceptPendingGatewayDefaultImplementation(e, "/api/GatewayManagement/GatewayManagement/AcceptPendingGateway", uriBuilderLocalVar.Path, gatewayManagementAcceptPendingGatewayRequestDto);
                Events.ExecuteOnErrorGatewayManagementGatewayManagementAcceptPendingGateway(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GatewayManagementGatewayManagementAcceptPendingGatewayApiResponse"/>
        /// </summary>
        public partial class GatewayManagementGatewayManagementAcceptPendingGatewayApiResponse : EleoncoreProxy.Client.ApiResponse, IGatewayManagementGatewayManagementAcceptPendingGatewayApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GatewayManagementGatewayManagementAcceptPendingGatewayApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GatewayManagementGatewayManagementAcceptPendingGatewayApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GatewayManagementGatewayManagementAcceptPendingGatewayApiResponse(ILogger<GatewayManagementGatewayManagementAcceptPendingGatewayApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGatewayManagementGatewayManagementAddGateway(Option<GatewayManagementGatewayDto> gatewayManagementGatewayDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="gatewayManagementGatewayDto"></param>
        /// <returns></returns>
        private void ValidateGatewayManagementGatewayManagementAddGateway(Option<GatewayManagementGatewayDto> gatewayManagementGatewayDto)
        {
            if (gatewayManagementGatewayDto.IsSet && gatewayManagementGatewayDto.Value == null)
                throw new ArgumentNullException(nameof(gatewayManagementGatewayDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayManagementGatewayDto"></param>
        private void AfterGatewayManagementGatewayManagementAddGatewayDefaultImplementation(IGatewayManagementGatewayManagementAddGatewayApiResponse apiResponseLocalVar, Option<GatewayManagementGatewayDto> gatewayManagementGatewayDto)
        {
            bool suppressDefaultLog = false;
            AfterGatewayManagementGatewayManagementAddGateway(ref suppressDefaultLog, apiResponseLocalVar, gatewayManagementGatewayDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayManagementGatewayDto"></param>
        partial void AfterGatewayManagementGatewayManagementAddGateway(ref bool suppressDefaultLog, IGatewayManagementGatewayManagementAddGatewayApiResponse apiResponseLocalVar, Option<GatewayManagementGatewayDto> gatewayManagementGatewayDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayManagementGatewayDto"></param>
        private void OnErrorGatewayManagementGatewayManagementAddGatewayDefaultImplementation(Exception exception, string pathFormat, string path, Option<GatewayManagementGatewayDto> gatewayManagementGatewayDto)
        {
            bool suppressDefaultLog = false;
            OnErrorGatewayManagementGatewayManagementAddGateway(ref suppressDefaultLog, exception, pathFormat, path, gatewayManagementGatewayDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayManagementGatewayDto"></param>
        partial void OnErrorGatewayManagementGatewayManagementAddGateway(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<GatewayManagementGatewayDto> gatewayManagementGatewayDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="gatewayManagementGatewayDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementAddGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementAddGatewayApiResponse> GatewayManagementGatewayManagementAddGatewayOrDefaultAsync(Option<GatewayManagementGatewayDto> gatewayManagementGatewayDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GatewayManagementGatewayManagementAddGatewayAsync(gatewayManagementGatewayDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayManagementGatewayDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementAddGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementAddGatewayApiResponse> GatewayManagementGatewayManagementAddGatewayAsync(Option<GatewayManagementGatewayDto> gatewayManagementGatewayDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "GatewayManagementApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateGatewayManagementGatewayManagementAddGateway(gatewayManagementGatewayDto);

                FormatGatewayManagementGatewayManagementAddGateway(gatewayManagementGatewayDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/GatewayManagement/GatewayManagement/AddGateway";

                    if (gatewayManagementGatewayDto.IsSet)
                        httpRequestMessageLocalVar.Content = (gatewayManagementGatewayDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(gatewayManagementGatewayDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GatewayManagementGatewayManagementAddGatewayApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GatewayManagementGatewayManagementAddGatewayApiResponse>();

                        GatewayManagementGatewayManagementAddGatewayApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/GatewayManagement/GatewayManagement/AddGateway", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGatewayManagementGatewayManagementAddGatewayDefaultImplementation(apiResponseLocalVar, gatewayManagementGatewayDto);

                        Events.ExecuteOnGatewayManagementGatewayManagementAddGateway(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGatewayManagementGatewayManagementAddGatewayDefaultImplementation(e, "/api/GatewayManagement/GatewayManagement/AddGateway", uriBuilderLocalVar.Path, gatewayManagementGatewayDto);
                Events.ExecuteOnErrorGatewayManagementGatewayManagementAddGateway(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GatewayManagementGatewayManagementAddGatewayApiResponse"/>
        /// </summary>
        public partial class GatewayManagementGatewayManagementAddGatewayApiResponse : EleoncoreProxy.Client.ApiResponse, IGatewayManagementGatewayManagementAddGatewayApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GatewayManagementGatewayManagementAddGatewayApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GatewayManagementGatewayManagementAddGatewayApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GatewayManagementGatewayManagementAddGatewayApiResponse(ILogger<GatewayManagementGatewayManagementAddGatewayApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public string Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<string>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out string result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGatewayManagementGatewayManagementCancelOngoingGatewayRegistration(ref Option<Guid> gatewayId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        private void AfterGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationDefaultImplementation(IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse apiResponseLocalVar, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            AfterGatewayManagementGatewayManagementCancelOngoingGatewayRegistration(ref suppressDefaultLog, apiResponseLocalVar, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        partial void AfterGatewayManagementGatewayManagementCancelOngoingGatewayRegistration(ref bool suppressDefaultLog, IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse apiResponseLocalVar, Option<Guid> gatewayId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        private void OnErrorGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            OnErrorGatewayManagementGatewayManagementCancelOngoingGatewayRegistration(ref suppressDefaultLog, exception, pathFormat, path, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        partial void OnErrorGatewayManagementGatewayManagementCancelOngoingGatewayRegistration(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> gatewayId);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse> GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationAsync(gatewayId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse> GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "GatewayManagementApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatGatewayManagementGatewayManagementCancelOngoingGatewayRegistration(ref gatewayId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/GatewayManagement/GatewayManagement/CancelOngoingGatewayRegistration";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gatewayId.IsSet)
                        parseQueryStringLocalVar["gatewayId"] = ClientUtils.ParameterToString(gatewayId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse>();

                        GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/GatewayManagement/GatewayManagement/CancelOngoingGatewayRegistration", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationDefaultImplementation(apiResponseLocalVar, gatewayId);

                        Events.ExecuteOnGatewayManagementGatewayManagementCancelOngoingGatewayRegistration(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationDefaultImplementation(e, "/api/GatewayManagement/GatewayManagement/CancelOngoingGatewayRegistration", uriBuilderLocalVar.Path, gatewayId);
                Events.ExecuteOnErrorGatewayManagementGatewayManagementCancelOngoingGatewayRegistration(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse"/>
        /// </summary>
        public partial class GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse : EleoncoreProxy.Client.ApiResponse, IGatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse(ILogger<GatewayManagementGatewayManagementCancelOngoingGatewayRegistrationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey(ref Option<Guid> gatewayId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        private void AfterGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyDefaultImplementation(IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse apiResponseLocalVar, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            AfterGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey(ref suppressDefaultLog, apiResponseLocalVar, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        partial void AfterGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey(ref bool suppressDefaultLog, IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse apiResponseLocalVar, Option<Guid> gatewayId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        private void OnErrorGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            OnErrorGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey(ref suppressDefaultLog, exception, pathFormat, path, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        partial void OnErrorGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> gatewayId);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse> GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyAsync(gatewayId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse> GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "GatewayManagementApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey(ref gatewayId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/GatewayManagement/GatewayManagement/GetCurrentGatewayRegistrationKey";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gatewayId.IsSet)
                        parseQueryStringLocalVar["gatewayId"] = ClientUtils.ParameterToString(gatewayId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse>();

                        GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/GatewayManagement/GatewayManagement/GetCurrentGatewayRegistrationKey", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyDefaultImplementation(apiResponseLocalVar, gatewayId);

                        Events.ExecuteOnGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyDefaultImplementation(e, "/api/GatewayManagement/GatewayManagement/GetCurrentGatewayRegistrationKey", uriBuilderLocalVar.Path, gatewayId);
                Events.ExecuteOnErrorGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKey(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse"/>
        /// </summary>
        public partial class GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse : EleoncoreProxy.Client.ApiResponse, IGatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse(ILogger<GatewayManagementGatewayManagementGetCurrentGatewayRegistrationKeyApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.GatewayManagementGatewayRegistrationKeyDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.GatewayManagementGatewayRegistrationKeyDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleoncoreProxy.Model.GatewayManagementGatewayRegistrationKeyDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGatewayManagementGatewayManagementGetGateway(ref Option<Guid> gatewayId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        private void AfterGatewayManagementGatewayManagementGetGatewayDefaultImplementation(IGatewayManagementGatewayManagementGetGatewayApiResponse apiResponseLocalVar, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            AfterGatewayManagementGatewayManagementGetGateway(ref suppressDefaultLog, apiResponseLocalVar, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        partial void AfterGatewayManagementGatewayManagementGetGateway(ref bool suppressDefaultLog, IGatewayManagementGatewayManagementGetGatewayApiResponse apiResponseLocalVar, Option<Guid> gatewayId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        private void OnErrorGatewayManagementGatewayManagementGetGatewayDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            OnErrorGatewayManagementGatewayManagementGetGateway(ref suppressDefaultLog, exception, pathFormat, path, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        partial void OnErrorGatewayManagementGatewayManagementGetGateway(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> gatewayId);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementGetGatewayApiResponse> GatewayManagementGatewayManagementGetGatewayOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GatewayManagementGatewayManagementGetGatewayAsync(gatewayId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementGetGatewayApiResponse> GatewayManagementGatewayManagementGetGatewayAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "GatewayManagementApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatGatewayManagementGatewayManagementGetGateway(ref gatewayId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/GatewayManagement/GatewayManagement/GetGateway";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gatewayId.IsSet)
                        parseQueryStringLocalVar["gatewayId"] = ClientUtils.ParameterToString(gatewayId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GatewayManagementGatewayManagementGetGatewayApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GatewayManagementGatewayManagementGetGatewayApiResponse>();

                        GatewayManagementGatewayManagementGetGatewayApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/GatewayManagement/GatewayManagement/GetGateway", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGatewayManagementGatewayManagementGetGatewayDefaultImplementation(apiResponseLocalVar, gatewayId);

                        Events.ExecuteOnGatewayManagementGatewayManagementGetGateway(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGatewayManagementGatewayManagementGetGatewayDefaultImplementation(e, "/api/GatewayManagement/GatewayManagement/GetGateway", uriBuilderLocalVar.Path, gatewayId);
                Events.ExecuteOnErrorGatewayManagementGatewayManagementGetGateway(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GatewayManagementGatewayManagementGetGatewayApiResponse"/>
        /// </summary>
        public partial class GatewayManagementGatewayManagementGetGatewayApiResponse : EleoncoreProxy.Client.ApiResponse, IGatewayManagementGatewayManagementGetGatewayApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GatewayManagementGatewayManagementGetGatewayApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GatewayManagementGatewayManagementGetGatewayApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GatewayManagementGatewayManagementGetGatewayApiResponse(ILogger<GatewayManagementGatewayManagementGetGatewayApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.GatewayManagementGatewayDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.GatewayManagementGatewayDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleoncoreProxy.Model.GatewayManagementGatewayDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGatewayManagementGatewayManagementGetGatewayList(ref Option<EleoncoreGatewayStatus> statusFilter);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="statusFilter"></param>
        private void AfterGatewayManagementGatewayManagementGetGatewayListDefaultImplementation(IGatewayManagementGatewayManagementGetGatewayListApiResponse apiResponseLocalVar, Option<EleoncoreGatewayStatus> statusFilter)
        {
            bool suppressDefaultLog = false;
            AfterGatewayManagementGatewayManagementGetGatewayList(ref suppressDefaultLog, apiResponseLocalVar, statusFilter);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="statusFilter"></param>
        partial void AfterGatewayManagementGatewayManagementGetGatewayList(ref bool suppressDefaultLog, IGatewayManagementGatewayManagementGetGatewayListApiResponse apiResponseLocalVar, Option<EleoncoreGatewayStatus> statusFilter);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="statusFilter"></param>
        private void OnErrorGatewayManagementGatewayManagementGetGatewayListDefaultImplementation(Exception exception, string pathFormat, string path, Option<EleoncoreGatewayStatus> statusFilter)
        {
            bool suppressDefaultLog = false;
            OnErrorGatewayManagementGatewayManagementGetGatewayList(ref suppressDefaultLog, exception, pathFormat, path, statusFilter);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="statusFilter"></param>
        partial void OnErrorGatewayManagementGatewayManagementGetGatewayList(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<EleoncoreGatewayStatus> statusFilter);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="statusFilter"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetGatewayListApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementGetGatewayListApiResponse> GatewayManagementGatewayManagementGetGatewayListOrDefaultAsync(Option<EleoncoreGatewayStatus> statusFilter = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GatewayManagementGatewayManagementGetGatewayListAsync(statusFilter, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="statusFilter"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementGetGatewayListApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementGetGatewayListApiResponse> GatewayManagementGatewayManagementGetGatewayListAsync(Option<EleoncoreGatewayStatus> statusFilter = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "GatewayManagementApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatGatewayManagementGatewayManagementGetGatewayList(ref statusFilter);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/GatewayManagement/GatewayManagement/GetGatewayList";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (statusFilter.IsSet)
                        parseQueryStringLocalVar["statusFilter"] = ClientUtils.ParameterToString(statusFilter.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GatewayManagementGatewayManagementGetGatewayListApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GatewayManagementGatewayManagementGetGatewayListApiResponse>();

                        GatewayManagementGatewayManagementGetGatewayListApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/GatewayManagement/GatewayManagement/GetGatewayList", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGatewayManagementGatewayManagementGetGatewayListDefaultImplementation(apiResponseLocalVar, statusFilter);

                        Events.ExecuteOnGatewayManagementGatewayManagementGetGatewayList(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGatewayManagementGatewayManagementGetGatewayListDefaultImplementation(e, "/api/GatewayManagement/GatewayManagement/GetGatewayList", uriBuilderLocalVar.Path, statusFilter);
                Events.ExecuteOnErrorGatewayManagementGatewayManagementGetGatewayList(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GatewayManagementGatewayManagementGetGatewayListApiResponse"/>
        /// </summary>
        public partial class GatewayManagementGatewayManagementGetGatewayListApiResponse : EleoncoreProxy.Client.ApiResponse, IGatewayManagementGatewayManagementGetGatewayListApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GatewayManagementGatewayManagementGetGatewayListApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GatewayManagementGatewayManagementGetGatewayListApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GatewayManagementGatewayManagementGetGatewayListApiResponse(ILogger<GatewayManagementGatewayManagementGetGatewayListApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<GatewayManagementGatewayDto> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<GatewayManagementGatewayDto>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<GatewayManagementGatewayDto> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGatewayManagementGatewayManagementRejectPendingGateway(ref Option<Guid> gatewayId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        private void AfterGatewayManagementGatewayManagementRejectPendingGatewayDefaultImplementation(IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse apiResponseLocalVar, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            AfterGatewayManagementGatewayManagementRejectPendingGateway(ref suppressDefaultLog, apiResponseLocalVar, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        partial void AfterGatewayManagementGatewayManagementRejectPendingGateway(ref bool suppressDefaultLog, IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse apiResponseLocalVar, Option<Guid> gatewayId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        private void OnErrorGatewayManagementGatewayManagementRejectPendingGatewayDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            OnErrorGatewayManagementGatewayManagementRejectPendingGateway(ref suppressDefaultLog, exception, pathFormat, path, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        partial void OnErrorGatewayManagementGatewayManagementRejectPendingGateway(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> gatewayId);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse> GatewayManagementGatewayManagementRejectPendingGatewayOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GatewayManagementGatewayManagementRejectPendingGatewayAsync(gatewayId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse> GatewayManagementGatewayManagementRejectPendingGatewayAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "GatewayManagementApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatGatewayManagementGatewayManagementRejectPendingGateway(ref gatewayId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/GatewayManagement/GatewayManagement/RejectPendingGateway";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gatewayId.IsSet)
                        parseQueryStringLocalVar["gatewayId"] = ClientUtils.ParameterToString(gatewayId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GatewayManagementGatewayManagementRejectPendingGatewayApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GatewayManagementGatewayManagementRejectPendingGatewayApiResponse>();

                        GatewayManagementGatewayManagementRejectPendingGatewayApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/GatewayManagement/GatewayManagement/RejectPendingGateway", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGatewayManagementGatewayManagementRejectPendingGatewayDefaultImplementation(apiResponseLocalVar, gatewayId);

                        Events.ExecuteOnGatewayManagementGatewayManagementRejectPendingGateway(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGatewayManagementGatewayManagementRejectPendingGatewayDefaultImplementation(e, "/api/GatewayManagement/GatewayManagement/RejectPendingGateway", uriBuilderLocalVar.Path, gatewayId);
                Events.ExecuteOnErrorGatewayManagementGatewayManagementRejectPendingGateway(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GatewayManagementGatewayManagementRejectPendingGatewayApiResponse"/>
        /// </summary>
        public partial class GatewayManagementGatewayManagementRejectPendingGatewayApiResponse : EleoncoreProxy.Client.ApiResponse, IGatewayManagementGatewayManagementRejectPendingGatewayApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GatewayManagementGatewayManagementRejectPendingGatewayApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GatewayManagementGatewayManagementRejectPendingGatewayApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GatewayManagementGatewayManagementRejectPendingGatewayApiResponse(ILogger<GatewayManagementGatewayManagementRejectPendingGatewayApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGatewayManagementGatewayManagementRemoveGateway(ref Option<Guid> gatewayId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        private void AfterGatewayManagementGatewayManagementRemoveGatewayDefaultImplementation(IGatewayManagementGatewayManagementRemoveGatewayApiResponse apiResponseLocalVar, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            AfterGatewayManagementGatewayManagementRemoveGateway(ref suppressDefaultLog, apiResponseLocalVar, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        partial void AfterGatewayManagementGatewayManagementRemoveGateway(ref bool suppressDefaultLog, IGatewayManagementGatewayManagementRemoveGatewayApiResponse apiResponseLocalVar, Option<Guid> gatewayId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        private void OnErrorGatewayManagementGatewayManagementRemoveGatewayDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            OnErrorGatewayManagementGatewayManagementRemoveGateway(ref suppressDefaultLog, exception, pathFormat, path, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        partial void OnErrorGatewayManagementGatewayManagementRemoveGateway(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> gatewayId);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRemoveGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementRemoveGatewayApiResponse> GatewayManagementGatewayManagementRemoveGatewayOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GatewayManagementGatewayManagementRemoveGatewayAsync(gatewayId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRemoveGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementRemoveGatewayApiResponse> GatewayManagementGatewayManagementRemoveGatewayAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "GatewayManagementApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatGatewayManagementGatewayManagementRemoveGateway(ref gatewayId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/GatewayManagement/GatewayManagement/RemoveGateway";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gatewayId.IsSet)
                        parseQueryStringLocalVar["gatewayId"] = ClientUtils.ParameterToString(gatewayId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GatewayManagementGatewayManagementRemoveGatewayApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GatewayManagementGatewayManagementRemoveGatewayApiResponse>();

                        GatewayManagementGatewayManagementRemoveGatewayApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/GatewayManagement/GatewayManagement/RemoveGateway", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGatewayManagementGatewayManagementRemoveGatewayDefaultImplementation(apiResponseLocalVar, gatewayId);

                        Events.ExecuteOnGatewayManagementGatewayManagementRemoveGateway(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGatewayManagementGatewayManagementRemoveGatewayDefaultImplementation(e, "/api/GatewayManagement/GatewayManagement/RemoveGateway", uriBuilderLocalVar.Path, gatewayId);
                Events.ExecuteOnErrorGatewayManagementGatewayManagementRemoveGateway(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GatewayManagementGatewayManagementRemoveGatewayApiResponse"/>
        /// </summary>
        public partial class GatewayManagementGatewayManagementRemoveGatewayApiResponse : EleoncoreProxy.Client.ApiResponse, IGatewayManagementGatewayManagementRemoveGatewayApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GatewayManagementGatewayManagementRemoveGatewayApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GatewayManagementGatewayManagementRemoveGatewayApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GatewayManagementGatewayManagementRemoveGatewayApiResponse(ILogger<GatewayManagementGatewayManagementRemoveGatewayApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGatewayManagementGatewayManagementRequestGatewayRegistration(ref Option<Guid> gatewayId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        private void AfterGatewayManagementGatewayManagementRequestGatewayRegistrationDefaultImplementation(IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse apiResponseLocalVar, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            AfterGatewayManagementGatewayManagementRequestGatewayRegistration(ref suppressDefaultLog, apiResponseLocalVar, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayId"></param>
        partial void AfterGatewayManagementGatewayManagementRequestGatewayRegistration(ref bool suppressDefaultLog, IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse apiResponseLocalVar, Option<Guid> gatewayId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        private void OnErrorGatewayManagementGatewayManagementRequestGatewayRegistrationDefaultImplementation(Exception exception, string pathFormat, string path, Option<Guid> gatewayId)
        {
            bool suppressDefaultLog = false;
            OnErrorGatewayManagementGatewayManagementRequestGatewayRegistration(ref suppressDefaultLog, exception, pathFormat, path, gatewayId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayId"></param>
        partial void OnErrorGatewayManagementGatewayManagementRequestGatewayRegistration(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<Guid> gatewayId);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse> GatewayManagementGatewayManagementRequestGatewayRegistrationOrDefaultAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GatewayManagementGatewayManagementRequestGatewayRegistrationAsync(gatewayId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse> GatewayManagementGatewayManagementRequestGatewayRegistrationAsync(Option<Guid> gatewayId = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "GatewayManagementApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                FormatGatewayManagementGatewayManagementRequestGatewayRegistration(ref gatewayId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/GatewayManagement/GatewayManagement/RequestGatewayRegistration";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gatewayId.IsSet)
                        parseQueryStringLocalVar["gatewayId"] = ClientUtils.ParameterToString(gatewayId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse>();

                        GatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/GatewayManagement/GatewayManagement/RequestGatewayRegistration", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGatewayManagementGatewayManagementRequestGatewayRegistrationDefaultImplementation(apiResponseLocalVar, gatewayId);

                        Events.ExecuteOnGatewayManagementGatewayManagementRequestGatewayRegistration(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGatewayManagementGatewayManagementRequestGatewayRegistrationDefaultImplementation(e, "/api/GatewayManagement/GatewayManagement/RequestGatewayRegistration", uriBuilderLocalVar.Path, gatewayId);
                Events.ExecuteOnErrorGatewayManagementGatewayManagementRequestGatewayRegistration(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse"/>
        /// </summary>
        public partial class GatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse : EleoncoreProxy.Client.ApiResponse, IGatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse(ILogger<GatewayManagementGatewayManagementRequestGatewayRegistrationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.GatewayManagementGatewayRegistrationKeyDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.GatewayManagementGatewayRegistrationKeyDto>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out EleoncoreProxy.Model.GatewayManagementGatewayRegistrationKeyDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGatewayManagementGatewayManagementUpdateGateway(Option<GatewayManagementUpdateGatewayRequestDto> gatewayManagementUpdateGatewayRequestDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="gatewayManagementUpdateGatewayRequestDto"></param>
        /// <returns></returns>
        private void ValidateGatewayManagementGatewayManagementUpdateGateway(Option<GatewayManagementUpdateGatewayRequestDto> gatewayManagementUpdateGatewayRequestDto)
        {
            if (gatewayManagementUpdateGatewayRequestDto.IsSet && gatewayManagementUpdateGatewayRequestDto.Value == null)
                throw new ArgumentNullException(nameof(gatewayManagementUpdateGatewayRequestDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayManagementUpdateGatewayRequestDto"></param>
        private void AfterGatewayManagementGatewayManagementUpdateGatewayDefaultImplementation(IGatewayManagementGatewayManagementUpdateGatewayApiResponse apiResponseLocalVar, Option<GatewayManagementUpdateGatewayRequestDto> gatewayManagementUpdateGatewayRequestDto)
        {
            bool suppressDefaultLog = false;
            AfterGatewayManagementGatewayManagementUpdateGateway(ref suppressDefaultLog, apiResponseLocalVar, gatewayManagementUpdateGatewayRequestDto);
            if (!suppressDefaultLog)
                Logger.LogDebug("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gatewayManagementUpdateGatewayRequestDto"></param>
        partial void AfterGatewayManagementGatewayManagementUpdateGateway(ref bool suppressDefaultLog, IGatewayManagementGatewayManagementUpdateGatewayApiResponse apiResponseLocalVar, Option<GatewayManagementUpdateGatewayRequestDto> gatewayManagementUpdateGatewayRequestDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayManagementUpdateGatewayRequestDto"></param>
        private void OnErrorGatewayManagementGatewayManagementUpdateGatewayDefaultImplementation(Exception exception, string pathFormat, string path, Option<GatewayManagementUpdateGatewayRequestDto> gatewayManagementUpdateGatewayRequestDto)
        {
            bool suppressDefaultLog = false;
            OnErrorGatewayManagementGatewayManagementUpdateGateway(ref suppressDefaultLog, exception, pathFormat, path, gatewayManagementUpdateGatewayRequestDto);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="gatewayManagementUpdateGatewayRequestDto"></param>
        partial void OnErrorGatewayManagementGatewayManagementUpdateGateway(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<GatewayManagementUpdateGatewayRequestDto> gatewayManagementUpdateGatewayRequestDto);

        /// <summary>
        ///  
        /// </summary>
        /// <param name="gatewayManagementUpdateGatewayRequestDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementUpdateGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementUpdateGatewayApiResponse> GatewayManagementGatewayManagementUpdateGatewayOrDefaultAsync(Option<GatewayManagementUpdateGatewayRequestDto> gatewayManagementUpdateGatewayRequestDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GatewayManagementGatewayManagementUpdateGatewayAsync(gatewayManagementUpdateGatewayRequestDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gatewayManagementUpdateGatewayRequestDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGatewayManagementGatewayManagementUpdateGatewayApiResponse"/>&gt;</returns>
        public async Task<IGatewayManagementGatewayManagementUpdateGatewayApiResponse> GatewayManagementGatewayManagementUpdateGatewayAsync(Option<GatewayManagementUpdateGatewayRequestDto> gatewayManagementUpdateGatewayRequestDto = default, System.Threading.CancellationToken cancellationToken = default)
        {
			var httpClient = SdkHttpClientFactory.Create(_apiConfigurator, _accessTokenType, "GatewayManagementApi");
			
			UriBuilder uriBuilderLocalVar = new UriBuilder(httpClient.BaseAddress);
			
            try
            {
                ValidateGatewayManagementGatewayManagementUpdateGateway(gatewayManagementUpdateGatewayRequestDto);

                FormatGatewayManagementGatewayManagementUpdateGateway(gatewayManagementUpdateGatewayRequestDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    // Construct URI
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.TrimEnd('/') + "/api/GatewayManagement/GatewayManagement/UpdateGateway";

                    if (gatewayManagementUpdateGatewayRequestDto.IsSet)
                        httpRequestMessageLocalVar.Content = (gatewayManagementUpdateGatewayRequestDto.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(gatewayManagementUpdateGatewayRequestDto.Value, _jsonSerializerOptions));

					
					httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await httpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GatewayManagementGatewayManagementUpdateGatewayApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GatewayManagementGatewayManagementUpdateGatewayApiResponse>();

                        GatewayManagementGatewayManagementUpdateGatewayApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/GatewayManagement/GatewayManagement/UpdateGateway", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGatewayManagementGatewayManagementUpdateGatewayDefaultImplementation(apiResponseLocalVar, gatewayManagementUpdateGatewayRequestDto);

                        Events.ExecuteOnGatewayManagementGatewayManagementUpdateGateway(apiResponseLocalVar);
						
                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGatewayManagementGatewayManagementUpdateGatewayDefaultImplementation(e, "/api/GatewayManagement/GatewayManagement/UpdateGateway", uriBuilderLocalVar.Path, gatewayManagementUpdateGatewayRequestDto);
                Events.ExecuteOnErrorGatewayManagementGatewayManagementUpdateGateway(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GatewayManagementGatewayManagementUpdateGatewayApiResponse"/>
        /// </summary>
        public partial class GatewayManagementGatewayManagementUpdateGatewayApiResponse : EleoncoreProxy.Client.ApiResponse, IGatewayManagementGatewayManagementUpdateGatewayApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GatewayManagementGatewayManagementUpdateGatewayApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GatewayManagementGatewayManagementUpdateGatewayApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GatewayManagementGatewayManagementUpdateGatewayApiResponse(ILogger<GatewayManagementGatewayManagementUpdateGatewayApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<bool>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out bool? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public bool IsNotImplemented => 501 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 501 NotImplemented
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse NotImplemented()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotImplemented
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 501 NotImplemented and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotImplemented([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotImplemented();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)501);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out EleoncoreProxy.Model.EleoncoreRemoteServiceErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}

